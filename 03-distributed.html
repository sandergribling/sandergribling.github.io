<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Introduction to distributed computing – Decentralized Finance and Blockchains</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<link href="./04-DolevStrong.html" rel="next">
<link href="./intro-computer-science.html" rel="prev">
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro-computer-science.html">Computer Science</a></li><li class="breadcrumb-item"><a href="./03-distributed.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduction to distributed computing</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Decentralized Finance and Blockchains</a> 
        <div class="sidebar-tools-main">
    <a href="./Decentralized-Finance-and-Blockchains.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-prelim.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Preliminaries</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./intro-computer-science.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Computer Science</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-distributed.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduction to distributed computing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-DolevStrong.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Dolev-Strong protocol</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-LongestChain.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Longest-chain protocols</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-ProofofWork.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Proof of Work</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./intro-game-theory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Game Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-proportional-rule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Proportional rule</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-tullock-contest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tullock contest</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#example-maintaining-copies-of-a-file" id="toc-example-maintaining-copies-of-a-file" class="nav-link active" data-scroll-target="#example-maintaining-copies-of-a-file"><span class="header-section-number">3.1</span> Example: maintaining copies of a file</a></li>
  <li><a href="#state-machine-replication-problem" id="toc-state-machine-replication-problem" class="nav-link" data-scroll-target="#state-machine-replication-problem"><span class="header-section-number">3.2</span> State Machine Replication problem</a>
  <ul class="collapse">
  <li><a href="#protocol-achieving-consistency" id="toc-protocol-achieving-consistency" class="nav-link" data-scroll-target="#protocol-achieving-consistency"><span class="header-section-number">3.2.1</span> Protocol achieving consistency</a></li>
  <li><a href="#sec-protocol_liveliness" id="toc-sec-protocol_liveliness" class="nav-link" data-scroll-target="#sec-protocol_liveliness"><span class="header-section-number">3.2.2</span> Protocol achieving liveness</a></li>
  </ul></li>
  <li><a href="#strong-assumptions-about-the-decentralized-setting" id="toc-strong-assumptions-about-the-decentralized-setting" class="nav-link" data-scroll-target="#strong-assumptions-about-the-decentralized-setting"><span class="header-section-number">3.3</span> (Strong) assumptions about the decentralized setting</a>
  <ul class="collapse">
  <li><a href="#assumption-1-the-set-of-nodes-is-known" id="toc-assumption-1-the-set-of-nodes-is-known" class="nav-link" data-scroll-target="#assumption-1-the-set-of-nodes-is-known"><span class="header-section-number">3.3.1</span> Assumption 1: the set of nodes is known</a></li>
  <li><a href="#assumption-2-signatures-exist-and-cannot-be-forged" id="toc-assumption-2-signatures-exist-and-cannot-be-forged" class="nav-link" data-scroll-target="#assumption-2-signatures-exist-and-cannot-be-forged"><span class="header-section-number">3.3.2</span> Assumption 2: signatures exist and cannot be forged</a></li>
  <li><a href="#assumption-3-synchronous-model" id="toc-assumption-3-synchronous-model" class="nav-link" data-scroll-target="#assumption-3-synchronous-model"><span class="header-section-number">3.3.3</span> Assumption 3: synchronous model</a></li>
  <li><a href="#discussion-of-the-assumptions" id="toc-discussion-of-the-assumptions" class="nav-link" data-scroll-target="#discussion-of-the-assumptions"><span class="header-section-number">3.3.4</span> Discussion of the assumptions</a></li>
  </ul></li>
  <li><a href="#sec-rotating" id="toc-sec-rotating" class="nav-link" data-scroll-target="#sec-rotating"><span class="header-section-number">3.4</span> Honest nodes</a>
  <ul class="collapse">
  <li><a href="#solving-the-smr-problem-under-assumptions-1234" id="toc-solving-the-smr-problem-under-assumptions-1234" class="nav-link" data-scroll-target="#solving-the-smr-problem-under-assumptions-1234"><span class="header-section-number">3.4.1</span> Solving the SMR problem under assumptions 1,2,3,4</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro-computer-science.html">Computer Science</a></li><li class="breadcrumb-item"><a href="./03-distributed.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduction to distributed computing</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-distributed" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduction to distributed computing</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""> <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Fira+Sans&amp;display=swap" rel="stylesheet"></p>
<p>In this chapter we will define some basic concepts and problems from the area of distributed computing.</p>
<p>We start this chapter with an example of a common distributed computing problem: that of making backups of a database and ensuring that these backups are synchronized. This is a problem that you have probably struggled with at some point: how do you properly backup the files on your hard disk? To look ahead, the problem that we aim to solve when we want to base cryptocurrencies on blockchains is very similar: the database would correspond to a complete list of the transactions that have ever occurred.</p>
<p>We then give a formal definition of the underlying problem: the State Machine Replication (SMR) problem. The second half of this chapter is devoted to formalizing and discussing various assumptions about distributed computing networks. The next chapters are dedicated to solutions of the SMR problem under increasingly more realistic assumptions.</p>
<section id="example-maintaining-copies-of-a-file" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="example-maintaining-copies-of-a-file"><span class="header-section-number">3.1</span> Example: maintaining copies of a file</h2>
<p>To set the stage, consider the following situation. On my computer, I have an excel file with the grades of all students who take this course. Naturally, I would like to make sure that I don’t lose this file. To do so, I can create multiple copies of this file and store them on different computers. That way, if one of the computers breaks, I still have a copy of the file on another computer. Making such a backup once, is easy enough. The problem that we will consider arises when I want to be able to update the file (for example, after the resit) in such a way that the various backups to agree with each other.</p>
<p>We start to see an outline of a distributed computing problem: we can view the different computers as nodes in a graph. If there are <span class="math inline">n</span> computers, there would be <span class="math inline">n</span> nodes in the graph. Our task would be to ensure that the <span class="math inline">n</span> computers each have an up to date copy of the file.</p>
<p>The above example is written from a <em>centralized</em> perspective. There is one agent, the “I” persona, that can simply perform the update to each copy of the file. In a <em>decentralized</em> setting, we would like the computers to run some sort of protocol that ensures that if I change the file on one of the computers, then the same change is made on all other devices. One quickly realizes that this protocol will require the devices to communicate. This brings us to the second part of the graph: the communication links between the computers determine the edge set of the graph.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><strong>Connection to blockchains</strong>: If we want to construct a cryptocurrency based on blockchains, then we are essentially interested in solving a similar type of problem. Indeed, we can draw the following analogy. Each participant in the cryptocurrency would correspond to a node in the network. The file that we want each participant to maintain consists of two parts: a list of the current balance of each account, and a full history of all transactions that have ever taken place between participants. In this variant of the problem, there is no natural “I” persona. The decentralized setting is built in: we want each of the nodes to be able to change the file. We do of course want all the nodes to agree on the same file! A change made by one of the nodes should be replicated by all other nodes.</p>
<p>In the next section we will formally define a generalization of the above examples.</p>
</section>
<section id="state-machine-replication-problem" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="state-machine-replication-problem"><span class="header-section-number">3.2</span> State Machine Replication problem</h2>
<p>Let us now give a formal definition of a problem that encompasses both examples from the previous section. In the distributed computing literature this problem is known as the State Machine Replication (SMR) problem. To explain the terminology: the state of the machine corresponds to the file that we wanted to maintain in the previous examples.</p>
<p>In the SMR problem we consider the following:</p>
<ol type="1">
<li>There is a set of <em>nodes</em> responsible for running a consensus protocol, and a set of <em>clients</em> who may submit “transactions” to one or more of the nodes.</li>
<li>Each node maintains a local file that we will call its <em>history</em>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
<li>Nodes can send messages to other nodes, and receive messages from other nodes.</li>
</ol>
<p>Some remarks are in order. We differentiate here between nodes and clients. The nodes are responsible for maintaining copies of the file. The clients may suggest modifications to the file by sending messages (instructions) to the nodes. For simplicity we assume here that modifications consist of adding information to the file (so no deletions). In a cryptocurrency application this is a reasonable assumption: the file – or history – represents the history of all transactions, which can only grow over time.</p>
<p>Informally, the SMR problem asks to keep all the nodes in sync. Meaning that the local histories of all nodes are the same.</p>
<p>More formally, the SMR problem is to design a protocol that is to be executed by each of the nodes. (Think of a piece of code.) The protocol is allowed to do the following operations:</p>
<ul>
<li>maintain or change the local state of the node,</li>
<li>receive messages from other nodes and from clients,</li>
<li>send messages to other nodes.</li>
</ul>
<p>We will see examples of protocol shortly. First, we need to define the properties that we want the protocol to have. In other words, how do we formalize “maintaining a file”? Here we can distinguish two key properties. The first is a <em>safety</em> guarantee: we want all nodes to agree on the same file. The second is a <em>liveness</em> guarantee: we want to be able to modify the file.</p>
<p><strong>Goal 1: Consistency.</strong> We say that a protocol satisfies consistency if all the nodes running it always agree on the history. That means that the local history of all the nodes is equal.</p>
<p>In particular, in the case where the local history is supposed to be a list of transactions, all nodes would agree on the order of the transactions.</p>
<p><strong>Goal 2: Liveness.</strong> Every “transaction” submitted by a client to at least one node is eventually added to every node’s local history.</p>
<p>For the moment, we view “transactions” as simply adding an entry in the file. That is, we ignore the very important financial question of whether the transaction is “valid” – agreeing with the current balance in each of the accounts.</p>
<p>The two goals together are non-trivial to satisfy. It is however not so hard design protocols that reach exactly one of the two goals.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<section id="protocol-achieving-consistency" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="protocol-achieving-consistency"><span class="header-section-number">3.2.1</span> Protocol achieving consistency</h3>
<p>Here is our first protocol. It will achieve consistency, but not liveness. We will describe the protocol by giving its <em>pseudocode</em>. That is, we describe the protocol mostly in words, without committing to a specific programming language.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Alg_Consistency: </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>1.  Initialize: local history H = [ ].</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>2.  Upon receiving a message m from a client do:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        Nothing.</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>3.  Upon receiving a message m from a node do:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        Nothing.</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As you can see, the protocol consists of three lines. The first line describes the initialization that the node performs. In this case, it defines its local history <span class="math inline">H</span> to be the empty list <span class="math inline">H = [\ ]</span>. The second line describes the behavior of the node when it receives a message from a client. The third line does the same for when it receives a message from a node. Here the last two actions are rather trivial: do nothing.</p>
<p>Although this is an extremely naive protocol, we can show that it does satisfy the first goal: consistency.</p>
<div id="lem-proto_consistency" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 3.1</strong></span> If all nodes in a distributed network run <code>Alg_Consistency</code>, then it satisfies consistency.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Assume all nodes in a distributed network run <code>Alg_Consistency</code>. To argue that we satisfy consistency, we observe that for each node and every moment in time the local history state equals the empty list <span class="math inline">[\ ]</span>. In particular, this means that all nodes agree on the same local history, at all times.</p>
</div>
<p>You are recommended to think about the following exercise before proceeding to the next section.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Convince yourself that a distributed network whose nodes all run <code>Alg_Consistency</code> does not guarantee liveness.</p>
</div>
</div>
</section>
<section id="sec-protocol_liveliness" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="sec-protocol_liveliness"><span class="header-section-number">3.2.2</span> Protocol achieving liveness</h3>
<p>As a second example, we will give a protocol that achieves liveness, but not necessarily consistence.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Alg_Liveness: </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>1.  Initialize: local history H = [ ].</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>2.  Upon receiving a message m from a client do:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        Append message m to H. </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>3.  Upon receiving a message m from a node do:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        Append message m to H.</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>4.  At midnight do:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        Send local history H to all other nodes.</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A couple of remarks are in order. First, the protocol now actually “does something”! In particular, a node will act upon a message that it receives from either a client or another node. Second, we see that nodes are no longer passive: they occasionally send messages to other nodes as well. Third, the protocol now – implicitly – assumes that a node is aware of the concept of time: it needs to perform a specified action every day at midnight. This is in stark contrast to the protocol <code>Alg_Consistency</code> which was purely <em>event-driven</em>: a node only had to take action when a message arrived. (“Took action” is maybe a slight exaggeration: the protocol doesn’t do anything when a message arrives.) For the purpose of this example, we will assume that all nodes agree on the current time. When an event happens once per day, this is a relatively mild assumption. It also means that messages from clients only get shared once per day, which might not be sufficiently quick depending on the application. At the other extreme, we could imagine the nodes want to share incoming messages every millisecond. In that case however, you might run into all kinds of issues: nodes might be too far apart for a message to pass from node <span class="math inline">A</span> to node <span class="math inline">B</span> within that time frame, or nodes might disagree on the current time (we are now measuring milliseconds after all). In that case, agreeing on the time is a much stronger assumption. We will revisit these – and other – assumptions in more detail later on. For now, let us prove that <code>Alg_Liveness</code> guarantees the liveness property.</p>
<div id="lem-proto_liveness" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 3.2</strong></span> If all nodes in a distributed network run <code>Alg_Liveness</code>, then it satisfies liveness.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Assume all nodes in a distributed network run <code>Alg_Consistency</code>. To argue that we satisfy liveness, we need to show that if a client sends a message <span class="math inline">m</span> to one or more nodes in the network, then it <em>eventually</em> gets added to the local history of every node. To that end, assume client <span class="math inline">i</span> sends a message <span class="math inline">m</span> to a group of nodes that includes node <span class="math inline">A</span>, on day <span class="math inline">1</span>. On day <span class="math inline">1</span> node <span class="math inline">A</span> receives message <span class="math inline">m</span> and adds it to its local history <span class="math inline">H_A</span>. Now consider an arbitrary node <span class="math inline">B</span> in this network that is distinct from <span class="math inline">A</span>. (It might have received message <span class="math inline">m</span> from client <span class="math inline">i</span> on day <span class="math inline">1</span> as well, in which case it added <span class="math inline">m</span> to <span class="math inline">H_B</span> on day <span class="math inline">1</span> and there is nothing left to show.) At the end of day <span class="math inline">1</span>, node <span class="math inline">A</span> sends their local history <span class="math inline">H_A</span> to all other nodes. Therefore, on day <span class="math inline">2</span>, node <span class="math inline">B</span> receives <span class="math inline">H_A</span> and appends it to <span class="math inline">H_B</span>. Since <span class="math inline">H_A</span> included the message <span class="math inline">m</span>, this means that <span class="math inline">H_B</span> now contains the message <span class="math inline">m</span> as well. Thus, the message <span class="math inline">m</span> is eventually added to the local history of every node.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
</div>
<p>It is important to note however that <code>Alg_Consistency</code> does not guarantee the consistency property. Can you see why?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider a distributed network containing two nodes <span class="math inline">A</span> and <span class="math inline">B</span> where on day <span class="math inline">1</span> client <span class="math inline">i</span> sends message <span class="math inline">m_A</span> to <span class="math inline">A</span> and <span class="math inline">j</span> sends message <span class="math inline">m_B</span> to <span class="math inline">B</span>. Describe the local history of each of the nodes on days <span class="math inline">1</span> and <span class="math inline">2</span>. What do you observe?</p>
</div>
</div>
</section>
</section>
<section id="strong-assumptions-about-the-decentralized-setting" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="strong-assumptions-about-the-decentralized-setting"><span class="header-section-number">3.3</span> (Strong) assumptions about the decentralized setting</h2>
<p>We will be working with a mathematical model of a real-world situation. We are therefore making some assumptions. In this section we list one possible set of assumptions. Some of the assumptions that we are making here are more restrictive than others. We will call such an assumption relatively <em>strong</em>. In later chapters we will replace these strong assumptions with weaker assumptions. While reading the next three assumptions, try to answer the following questions: is it a weak or strong assumption? Do I know an application where it holds / does not hold?</p>
<section id="assumption-1-the-set-of-nodes-is-known" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="assumption-1-the-set-of-nodes-is-known"><span class="header-section-number">3.3.1</span> Assumption 1: the set of nodes is known</h3>
<p>This assumption is also referred to as the <em>permissioned</em> setting. It assumes the set of nodes in the network is fixed and known to all nodes, moreover it assumes that each node has a unique identifier that is also known to all other nodes. We will frequently use <span class="math inline">n \in \mathbb{N}</span> to denote the number of nodes. This allows us to use the numbers between <span class="math inline">1</span> and <span class="math inline">n</span> as unique identifiers.</p>
<p>Key advantages:</p>
<ul>
<li>It allows <em>majority voting</em>.</li>
<li>One can order the nodes based on their identifier.</li>
</ul>
</section>
<section id="assumption-2-signatures-exist-and-cannot-be-forged" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="assumption-2-signatures-exist-and-cannot-be-forged"><span class="header-section-number">3.3.2</span> Assumption 2: signatures exist and cannot be forged</h3>
<p>This assumption can be viewed as an extension of Assumption 1. We assume that nodes can add their signature to a message. By this we mean that if node <span class="math inline">A</span> sends a message <span class="math inline">m</span> (to an arbitrary node), then they can add their signature to it. All other nodes have a verification procedure that can correctly determine whether node <span class="math inline">A</span> signed message <span class="math inline">m</span>. No other node can <em>forge</em> <span class="math inline">A</span>’s signature: no other node can add a ‘signature’ that the verification procedure would accept as <span class="math inline">A</span>’s signature. This is an example of a <em>trusted setup</em>. This assumption is also referred to as assuming Public Key Infrastructure (PKI).</p>
<p>We will not go into further details about this assumption in this course; we will (happily) assume that it holds and not go into details of how one would implement it in a real-world scenario. (It is a relatively mild assumption however.)</p>
<p>Key advantage:</p>
<ul>
<li>It allows us to trust who sent which message.</li>
</ul>
</section>
<section id="assumption-3-synchronous-model" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="assumption-3-synchronous-model"><span class="header-section-number">3.3.3</span> Assumption 3: synchronous model</h3>
<p>This is an assumption about the (reliability of the) communication network. Formally, we require the following two sub-assumptions:</p>
<ol type="1">
<li>All nodes have access to a shared clock.</li>
<li>Bounded message delays: messages arrive within a predetermined amount of time.</li>
</ol>
<p>Together, these two assumptions allow us to divide time into smaller intervals in such a way that that messages sent at the start of an interval arrive before the end of the interval. To avoid having to specify the bounded message delay, we will simply number the intervals. Concretely, we thus assume that messages sent at the start of (or simply <em>in</em>) interval <span class="math inline">t</span> arrive at their intended recipient before the start of interval <span class="math inline">t+1</span>. We will often refer to the intervals as <em>rounds</em>.</p>
<p>Key advantage:</p>
<ul>
<li>It allows us to define <em>rounds</em> (see above).</li>
</ul>
</section>
<section id="discussion-of-the-assumptions" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="discussion-of-the-assumptions"><span class="header-section-number">3.3.4</span> Discussion of the assumptions</h3>
<p>Assumption <span class="math inline">1</span> is realistic in some scenarios: if we are using multiple computers to create a backup of a file (e.g.&nbsp;a list of grades), then it reasonable to assume that we know how many computers we are going to use. (There is a central entity that determines the number of nodes.) For our second motivating example however, blockchains, this is a very unrealistic assumption! Not knowing the set of nodes participating in the blockchain protocol is in fact a key feature that we are aiming for. We would like a blockchain protocol to be able to function in a completely decentralized manner, with nodes being able to enter (or leave) the network while the protocol is active.</p>
<p>Assumption <span class="math inline">2</span>, as mentioned above, is one that we will simply assume throughout the course.</p>
<p>Assumption <span class="math inline">3</span> is again realistic in some scenarios, but not in others. We have seen an example of a protocol that worked in the synchronous model in <a href="#sec-protocol_liveliness" class="quarto-xref"><span>Section 3.2.2</span></a>: the <code>Alg_Consistency</code> protocol. The synchronous model makes optimistic assumptions and therefore serves as a good sanity check when designing protocols: the protocol should at least function correctly in the synchronous model. In <a href="04-DolevStrong.html" class="quarto-xref"><span>Chapter 4</span></a> we will work with the synchronous model. In the later chapters <a href="05-LongestChain.html" class="quarto-xref"><span>Chapter 5</span></a> and <a href="06-ProofofWork.html" class="quarto-xref"><span>Chapter 6</span></a> we will encounter protocols that make milder assumptions.</p>
</section>
</section>
<section id="sec-rotating" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-rotating"><span class="header-section-number">3.4</span> Honest nodes</h2>
<p>The final assumption is about whether we assume nodes to be <em>‘honest’</em> or <em>‘dishonest’</em>. We say that a node is <em>honest</em> if it executes the intended protocol. Any node that deviates from the intended protocol is called <em>dishonest</em> or <em>faulty</em>. Note that honesty in this context is a description of the nodes behavior, not its intentions. In the example of creating backups of a list of grades, it is for example perfectly reasonable to assume that all nodes have good intentions, but we would like a protocol to `work well’ even if one of the nodes breaks and is therefore unable to follow the protocol. We therefore prefer the term <em>faulty</em> for nodes that are not honest.</p>
<p>The assumption that we will make in this section (and only this section) is a very strong one:</p>
<p><strong>Assumption 4</strong>: All nodes are honest.</p>
<p>Naturally, we would like to relax this assumption as soon as possible. In the next chapter we will indeed replace it with a much milder assumption: there we assume a bound <span class="math inline">f</span> on the number of faulty nodes.</p>
<section id="solving-the-smr-problem-under-assumptions-1234" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="solving-the-smr-problem-under-assumptions-1234"><span class="header-section-number">3.4.1</span> Solving the SMR problem under assumptions 1,2,3,4</h3>
<p>Here we show how to solve the SMR problem under the assumptions <span class="math inline">1</span>, <span class="math inline">2</span>, <span class="math inline">3</span>, and <span class="math inline">4</span>. That is, we work in the permissioned, synchronous model, we assume PKI and that all nodes are honest.</p>
<p>As a reminder, we want to design a protocol that guarantees consistency and liveness for the SMR problem. We have already seen two protocols that achieve either consistency or liveness. In particular, in <a href="#lem-proto_liveness" class="quarto-xref">Lemma&nbsp;<span>3.2</span></a> we have shown that <code>Alg_Liveness</code> guarantees the liveness property. In the subsequent discussion we have seen that this protocol does not guarantee consistency: it can happen that two nodes disagree on the order of transactions in their local history. The ‘issue’ here was that every node had the ‘right’ to append transactions to the local history of other nodes, which could lead to disagreements on the order that transactions are written down. The protocol that we describe here resolves this issue by selecting a leader in each round, who is the only one with the permission to write in that round.</p>
<p><strong>Coordinating via rotating leaders</strong>: since we are in the permissioned setting, we know the number of nodes participating in the network, say <span class="math inline">n</span>. We can there do the following:</p>
<ul>
<li><p>in round <span class="math inline">1</span>, node <span class="math inline">1</span> is called the leader and all other nodes are called followers,</p></li>
<li><p>in round <span class="math inline">2</span>, node <span class="math inline">2</span> is called the leader and all other nodes are called followers, …</p></li>
<li><p>in round <span class="math inline">n</span>, node <span class="math inline">n</span> is called the leader and all other nodes are called followers After <span class="math inline">n</span> rounds, we reset the clock and start again as in round <span class="math inline">1</span>. In other words, we are rotating the leaders.</p></li>
</ul>
<p>We now describe the protocol for the leader and follower nodes separately. For ease of notation, we always assume that nodes initialize their local history to <span class="math inline">H = [\ ]</span> at the start of the protocol. We additionally allow the nodes to use some local workspace <span class="math inline">W</span>, which they can use to store information (temporarily); it is not part of the local history state.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Alg_Leader(t): </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>1.  Upon receiving a message m from a client do:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        Append message m to the local workspace W. </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>2.  At the end of the round do:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        Remove from W the messages that are already part of H. </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        Append W to H and send W to all other nodes. </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        Reset W = [ ].</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Alg_Follower(t): </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>1.  Upon receiving a message m from a client do:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        Append message m to the local workspace W. </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>2.  Upon receiving a message m from a node do:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        If m is signed by the leader of the current round t do:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                Append m to H. </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        Else do:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                Nothing. </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Our claim is that if the nodes in a distributed network adhere to the above protocol, then both liveness and consistency are guaranteed.</p>
<div id="lem-proto_RR" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 3.3</strong></span> If all nodes in a distributed network run the ‘coordinating via rotating leaders’ protocol, then it satisfies liveness and consistency.</p>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p>Prove <a href="#lem-proto_RR" class="quarto-xref">Lemma&nbsp;<span>3.3</span></a>.</p>
</div>
</div>
<!-- To encourage you to attempt the exercise yourself first, the solution is "hidden" (in the HTML version). Click on the orange bar to show a possible solution. 

::: {.callout-caution collapse="true"}
## Solution

We need to verify two properties: consistency and liveness. We first prove that consistency is guaranteed, using induction. Note that all nodes initialize to the same local history state, $H = [\ ]$. Let us call this initialization phase round $0$. Then consistency holds at round $0$. Now, as our induction hypothesis, assume consistency holds for the first $t-1$ rounds. That is, all nodes agree on the local history state $H$ during the first $t-1$ rounds. We show that consistency holds in round $t$ as well. Indeed, in the $t$-th round the leader looks at their local workspace $W$, it removes all transactions that have previously been added to $H$, it then adds $W$ to $H$ and instructs all other nodes to do the same. (All other nodes indeed proceed to do the same.) This shows that all nodes agree on $H$ at the end of round $t$ as well. 

It remains to argue that the protocol guarantees liveness. Suppose a client $i$ sends a transaction $m$ to at least one node. Since every node is elected as leader in one of the $n$ nodes, the transaction $m$ is eventually added to $H$. 
::: -->


</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>In this problem, it is natural to assume that communication works both ways. Therefore the graph would be undirected.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It represents for example an ordered list of transactions that only grows over time.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Warning: these protocols might seem a bit silly, they are meant as an easy introduction to thinking about protocols.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>In this case, <em>eventually</em> means at most one day after the client sends the message to at least one node in the network.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro-computer-science.html" class="pagination-link" aria-label="Computer Science">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Computer Science</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./04-DolevStrong.html" class="pagination-link" aria-label="The Dolev-Strong protocol">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Dolev-Strong protocol</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>
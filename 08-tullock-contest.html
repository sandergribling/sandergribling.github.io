<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.52">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>8&nbsp; Tullock contest – Decentralized Finance and Blockchains</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<link href="./07-proportional-rule.html" rel="prev">
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="style.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro-game-theory.html">Game Theory</a></li><li class="breadcrumb-item"><a href="./08-tullock-contest.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tullock contest</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Decentralized Finance and Blockchains</a> 
        <div class="sidebar-tools-main">
    <a href="./Decentralized-Finance-and-Blockchains.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-prelim.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Preliminaries</span></span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./intro-computer-science.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Computer Science</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-distributed.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Introduction to distributed computing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-DolevStrong.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">The Dolev-Strong protocol</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-LongestChain.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Longest-chain protocols</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-ProofofWork.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Proof of Work</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./intro-game-theory.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Game Theory</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-proportional-rule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Proportional rule</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-tullock-contest.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tullock contest</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#tullock-contest" id="toc-tullock-contest" class="nav-link active" data-scroll-target="#tullock-contest"><span class="header-section-number">8.1</span> Tullock contest</a></li>
  <li><a href="#sec-pne" id="toc-sec-pne" class="nav-link" data-scroll-target="#sec-pne"><span class="header-section-number">8.2</span> Pure Nash equilibrium</a>
  <ul class="collapse">
  <li><a href="#computation-for-n-2" id="toc-computation-for-n-2" class="nav-link" data-scroll-target="#computation-for-n-2"><span class="header-section-number">8.2.1</span> Computation for <span class="math inline">n = 2</span></a></li>
  <li><a href="#computation-for-n-2-1" id="toc-computation-for-n-2-1" class="nav-link" data-scroll-target="#computation-for-n-2-1"><span class="header-section-number">8.2.2</span> Computation for <span class="math inline">n &gt; 2</span></a></li>
  </ul></li>
  <li><a href="#best-response-dynamics" id="toc-best-response-dynamics" class="nav-link" data-scroll-target="#best-response-dynamics"><span class="header-section-number">8.3</span> Best response dynamics</a>
  <ul class="collapse">
  <li><a href="#potential-function" id="toc-potential-function" class="nav-link" data-scroll-target="#potential-function"><span class="header-section-number">8.3.1</span> Potential function</a></li>
  <li><a href="#convergence-to-epsilon-pne" id="toc-convergence-to-epsilon-pne" class="nav-link" data-scroll-target="#convergence-to-epsilon-pne"><span class="header-section-number">8.3.2</span> Convergence to <span class="math inline">\epsilon</span>-PNE</a></li>
  </ul></li>
  <li><a href="#two-model-variations" id="toc-two-model-variations" class="nav-link" data-scroll-target="#two-model-variations"><span class="header-section-number">8.4</span> Two model variations</a>
  <ul class="collapse">
  <li><a href="#concave-utilities" id="toc-concave-utilities" class="nav-link" data-scroll-target="#concave-utilities"><span class="header-section-number">8.4.1</span> Concave utilities</a></li>
  <li><a href="#economies-of-scale" id="toc-economies-of-scale" class="nav-link" data-scroll-target="#economies-of-scale"><span class="header-section-number">8.4.2</span> Economies of scale</a></li>
  </ul></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements"><span class="header-section-number">8.5</span> Acknowledgements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro-game-theory.html">Game Theory</a></li><li class="breadcrumb-item"><a href="./08-tullock-contest.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tullock contest</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tullock contest</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><link rel="preconnect" href="https://fonts.googleapis.com"> <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""> <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Fira+Sans&amp;display=swap" rel="stylesheet"></p>
<p>In the previous chapter we saw that (in theory) the proportional allocation rule is a good way to divide the (expected) rewards of mining a unit of cryptocurrency. One aspect that this rule did not take into account is the fact that it costs time and money to guess solutions for the puzzle contest that determines the leader of the next round in the Proof-of-Work protocol.</p>
<p>A more realistic way of denoting the reward, or said better, the <em>(expected) payoff</em> of miner <span class="math inline">i</span>, is <span class="math display">
\frac{\mu_i}{\sum_j \mu_j} - c_i(\mu_i)
</span> where the function <span class="math inline">c_i : \mathbb{R}_{\geq 0} \rightarrow \mathbb{R}_{\geq 0}</span> is a nondecreasing cost function: The more hashing power miner <span class="math inline">i</span> uses, the higher the cost <span class="math inline">c_i(\mu_i)</span> she has to pay. For example, this cost could model the energy consumption of the computers used to guess solutions with. Note that <span class="math inline">c_i</span> is a miner-specific function.</p>
<p>In this chapter we will allow real values of <span class="math inline">\mu_i</span>, as opposed to only integer values, so that the payoff of miner <span class="math inline">i</span> is continuous. For simplicity, we will assume that for every <span class="math inline">i=1,\dots,n</span>, <span class="math inline">c_i</span> is a linear function of the form <span class="math inline">c_i(\mu_i) = a_i\cdot \mu_i</span> for <span class="math inline">a_i &gt; 0</span>, so that the payoff of miner <span class="math inline">i</span> becomes <span class="math display">
\frac{\mu_i}{\sum_j \mu_j} - a_i \cdot \mu_i.
</span> In the literature, the payoff is often normalized by the value <span class="math inline">a_i</span>, so that we finally define <span class="math display">
p_i(\mu) = w_i \cdot \frac{\mu_i}{\sum_j \mu_j} - \mu_i
</span> where <span class="math inline">w_i = 1/a_i</span>. This will be the payoff function that we work with in this chapter.</p>
<!--
> In the literature, more general payoff functions are often considered, where 
$$
p_i(\mu) = U_i\left(\frac{\mu_i}{\sum_j \mu_j}\right) - \mu_i
$$ 
with $U_i: \mathbb{R}_{\geq 0} \rightarrow \mathbb{R}_{\geq 0}$ a strictly increasing, concave utility function with $U_i(0) = 0$. These utility functions are similar to those we considered in the previous chapter. Our setting in this chapter is a special case with $U_i(x) = w_i x$.
-->
<p>The proportional rule had the property that a miner <span class="math inline">i</span> could increase its reward by increasing their hash rate <span class="math inline">\mu_i</span>. If the goal of a miner is to maximize its payoff <span class="math inline">p_i(\mu)</span>, it is no longer necessarily optimal for her to increase her hash rate, because <span class="math inline">\lim_{\mu_i \rightarrow \infty} p_i(\mu) = -\infty</span> (note that the other hash rates are kept constant in this reasoning).</p>
<p>This gives rise to a <em>strategic</em> consideration for miner <span class="math inline">i</span>. Knowning the hash rates <span class="math display">
\mu_{-i} = (\mu_1,\dots,\mu_{i-1},\mu_{i+1},\dots,\mu_n)
</span> of the other miners, what hash rate <span class="math inline">\mu_i</span> maximizes the payoff function <span class="math inline">p_i(\mu)</span>? This setting, in which every miner has the goal of maximizing their indivual payoff function, can be seen as a <em>non-cooperative</em> game. It is important to observe that the payoff of miner <span class="math inline">i</span> depends on the choices made by the other miners, i.e., the vector <span class="math inline">\mu_{-i}</span>!</p>
<p>The assumption here that we know the hash rates of all the other miners is quite strong, but not necessarily unrealistic. If we interpret the miners as mining pools, then in real-life there are good estimates of the hash rates of these pools, see for example the overview <a href="https://www.blockchain.com/explorer/charts/pools">here</a>.</p>
<p>In the next section we will summarize the above setting, known as a <em>Tullock contest</em>. Although we approach this problem from the perspective of blockchains, Tullock contests have many more application areas. For example, think of an election, where different candidates invest money in their campaign, but only one candidate can win in the end.</p>
<section id="tullock-contest" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="tullock-contest"><span class="header-section-number">8.1</span> Tullock contest</h2>
<p>A <em>Tullock contest</em> is a winner-takes-all game in which there are <span class="math inline">n</span> miners (also called contestants or players). Every miner has <em>strategy space</em> <span class="math inline">S_i = \mathbb{R}_{\geq 0}</span> from which she chooses a <em>strategy</em> (i.e., hash rate) <span class="math inline">\mu_i \geq 0</span>. The vector <span class="math inline">\mu</span> is called a <em>strategy profile</em>.</p>
<p>The goal of every miner is to maximizer their payoff function <span class="math display">
p_i(\mu) = w_i \cdot \frac{\mu_i}{\sum_j \mu_j} - \mu_i.
</span></p>
<p>We make one conventional assumption, which is that <span class="math inline">p_i(0,0,\dots,0) = 0</span>, i.e., if all the hash rates are <span class="math inline">0</span> then every player has a payoff of <span class="math inline">0</span>. Observe that the Tullock contest is completely described by its <em>input parameters</em> <span class="math inline">w_1,\dots,w_n</span>.</p>
<p>How is this game played? There are many ways to define the <em>dynamics</em> of the game; we will consider an elementary setting. Suppose that at the start of the game, every miner <span class="math inline">i</span> has chosen some hash rate <span class="math inline">\mu_i</span> and that all miners know the hash rate vector <span class="math inline">\mu = (\mu_1,\dots,\mu_n)</span>.</p>
<p>We first allow miner <span class="math inline">1</span> to change it hash rate <span class="math inline">\mu_1</span> so that its payoff function <span class="math inline">p_1(\mu)</span> is maximized (while keeping the other hash rates <span class="math inline">\mu_j</span> fixed). Suppose miner <span class="math inline">1</span> changes to hash rate <span class="math inline">\mu_1'</span>. Next, we allow miner <span class="math inline">2</span> to change its hash rate <span class="math inline">\mu_2</span> to maximze its payoff function <span class="math inline">p_2(\mu_1',\mu_2,\dots,\mu_n)</span>. We keep repeating this process until all miners <span class="math inline">i</span> have had the option to change their hash rate to some othe rate <span class="math inline">\mu_i'</span>. Then we go back to the first miner.</p>
<p>Because one or more miners might have changed their initially chosen hash rate, the payoff of miner <span class="math inline">1</span> might have changed in the meantime, in which case they need to re-optimize their payoff. We keep iterating over the miners until we reach the point where no miner has an incentive to change its hash rate under the present hash rate vector, i.e., until we have reached an <em>equilibrium</em> state.</p>
<p>One question that should be in your mind right now is the following: Are the above-described dynamics guaranteed to converge, i.e., is it guaranteed that in a <em>finite number</em> iterations we reach an equilibrium state? How do we describe the resulting equilibrium state mathematically? These are questions we will explore in the coming sections.</p>
<p>As a final remark here: The most important aspect of the dynamics is that at most one miner at a time changes it hash rate. It is also possible to consider dynamics in which miners can change simulateously, but we do not allow this for now.</p>
</section>
<section id="sec-pne" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="sec-pne"><span class="header-section-number">8.2</span> Pure Nash equilibrium</h2>
<p>We start this section with a mathematical description of an equilbrium state. A unitlateral deviation of miner <span class="math inline">i</span> to hash rate <span class="math inline">\mu_i'</span> is described by the hash rate vector <span class="math display">
(\mu_i',\mu_{-i}) = (\mu_1,\dots,\mu_{i-1},\mu_i',\mu_{i+1},\dots,\mu_n),
</span> i.e., the vector in which only miner <span class="math inline">i</span> changes its rate, while all the other rates are kept fixed. An equilibrium, also called <em>pure Nash equilibrium</em>, is a hash rate vector in which no miner <span class="math inline">i</span> can unilaterally deviate in order to improve her payoff. We next give the formal definition of this statement.</p>
<div id="def-pne" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 8.1 (Pure Nash equilibrium)</strong></span> A hash rate vector <span class="math inline">\mu</span> is a pure Nash equilibrium (PNE) if for all <span class="math inline">i = 1,\dots,n</span>, it holds that <span class="math display">
p_i(\mu) \geq p_i(\mu_i',\mu_{-i})
</span> for all <span class="math inline">\mu_i' \geq 0</span>.</p>
</div>
<p>Another way to look at the inequalities in the definition of a pure Nash equilibria <span class="math inline">\mu</span> is that for every <span class="math inline">i</span> the value <span class="math inline">\mu_i</span> maximizes the <em>best response function</em> <span class="math display">
g_i(x) = p_i(x,\mu_{-i}),
</span> i.e., the function in which the hash rates of all the other miners are kept fixed.</p>
<p>There is a small technical issue if <span class="math inline">\mu_{-i}</span> is the all-zeros vector, in which case the best response of player <span class="math inline">i</span> is to send <span class="math inline">x \rightarrow 0</span>. We will instead assume that in this case the best response of miner <span class="math inline">i</span> is to set <span class="math inline">\mu_i = \delta</span> with <span class="math inline">\delta &gt; 0</span> very small, such as <span class="math inline">\delta = 10^{-10} \cdot \min_i w_i</span>.</p>
<blockquote class="blockquote">
<p>You might have seen the concept of a Nash equilibrium in an earlier game theory course. A Nash equilbrium is usually defined as a probability distribution over all possible strategies (i.e., all possible hash rates in our case). By using the term “pure”, we emphasize that we do not allow randomization over strategies, but that every miner deterministically (meaning with probability <span class="math inline">1</span>) chooses a hash rate.</p>
</blockquote>
<p>Let us look at a small example in which we verify the definition of a pure Nash equilibrium for a given vector <span class="math inline">\mu</span>. Let us take <span class="math inline">w_1 = 4</span> and <span class="math inline">w_2 = 2</span>, so that <span class="math display">
p_1(\mu) = p_1(\mu_1,\mu_2) = 4 \cdot \frac{\mu_1}{\mu_1 + \mu_2} - \mu_1
</span> and <span class="math display">
p_2(\mu) = p_2(\mu_1,\mu_2) = 2 \cdot \frac{\mu_2}{\mu_1 + \mu_2} - \mu_2
</span> and recall that by convention, we have <span class="math inline">p_1(0,0) = p_2(0,0) = 0</span>.</p>
<p>We claim that <span class="math inline">\mu = (8/9,4/9)</span> is a pure Nash equilibrium of this game. We need to show that <span class="math inline">\mu_1 = 8/9</span> maximizes the best response function <span class="math display">
g_1(x) = 4 \cdot \frac{x}{x + 4/9} - x
</span> of the first miner, and that <span class="math inline">\mu_2 = 4/9</span> maximizes the best response function <span class="math display">
g_2(x) = 2 \cdot \frac{x}{8/9 + x} - x
</span> of the second miner. This is illustrated in the Python figure below.</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="f80ad459" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Show code generating the plot below</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the functions g1(x) and g2(x)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g1(x):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">4</span> <span class="op">*</span> x <span class="op">/</span> (x <span class="op">+</span> <span class="dv">4</span> <span class="op">/</span> <span class="dv">9</span>) <span class="op">-</span> x</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> g2(x):</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span> x <span class="op">/</span> (x <span class="op">+</span> <span class="dv">8</span> <span class="op">/</span> <span class="dv">9</span>) <span class="op">-</span> x</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate x values</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">4</span>, <span class="dv">400</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the corresponding y values for both functions</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>y1 <span class="op">=</span> g1(x)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>y2 <span class="op">=</span> g2(x)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Function for maximization of g1</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neg_g1(x):</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>g1(x)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Function for maximization of g2</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neg_g2(x):</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>g2(x)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Minimize the negative of the functions to find the maximum</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>result_g1 <span class="op">=</span> minimize(neg_g1, <span class="dv">1</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>result_g2 <span class="op">=</span> minimize(neg_g2, <span class="dv">1</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the x values at the maxima</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>x_max_g1 <span class="op">=</span> result_g1.x[<span class="dv">0</span>]</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>x_max_g2 <span class="op">=</span> result_g2.x[<span class="dv">0</span>]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the corresponding y-values at the maxima</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>y_max_g1 <span class="op">=</span> g1(x_max_g1)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>y_max_g2 <span class="op">=</span> g2(x_max_g2)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the plot</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot functions and maxima</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y1, label<span class="op">=</span><span class="vs">r"$g_1(x) = 4x/(x + 4/9) - x$"</span>, color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>plt.axvline(x_max_g1, color<span class="op">=</span><span class="st">'blue'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>,</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="ss">f"Max. of $g_1$ at x = </span><span class="sc">{</span>x_max_g1<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>plt.plot(x, y2, label<span class="op">=</span><span class="vs">r"$g_2(x) =  2x/(x + 8/9) - x$"</span>, color<span class="op">=</span><span class="st">'red'</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>plt.axvline(x_max_g2, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, </span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>                label<span class="op">=</span><span class="ss">f"Max. of $g_2$ at x = </span><span class="sc">{</span>x_max_g2<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co"># Add titles and labels</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Plots of best response functions $g_1(x)$ and $g_2(x)$"</span>)</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"x"</span>)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="ss">f"$g_i(x)$"</span>)</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>plt.xlim(<span class="dv">0</span>,<span class="dv">4</span>)</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>])</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="08-tullock-contest_files/figure-html/cell-2-output-1.png" class="quarto-figure quarto-figure-center figure-img" width="594" height="450"></p>
</figure>
</div>
</div>
</div>
<p>We can formally prove this with some elementary calculus,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> which we will do next for the first miner. We have to show that <span class="math inline">x = 8/9</span> maximizes the best response function <span class="math inline">g_1</span>. Note that we want to compute the maximum of the function <span class="math inline">g_1(x)</span> on the interval <span class="math inline">[0,\infty)</span>. Observe that <span class="math inline">g_1(0) = 0</span> and <span class="math inline">\lim_{x \rightarrow \infty} g_1(x) = -\infty</span>. Furthermore, <span class="math inline">g_1</span> is strictly concave on <span class="math inline">[0,\infty)</span>, as the second derivative <span class="math inline">g_1''(x) &lt; 0</span> there. This means that <span class="math inline">g_1</span> has an internal maximum on <span class="math inline">(0,\infty)</span> if the equation <span class="math inline">g_1'(x) = 0</span> has a solution on <span class="math inline">[0,\infty)</span>, i.e., if the first derivative is <span class="math inline">0</span> for a point in that interval. Otherwise, <span class="math inline">g_1</span> is decreasing in which case the maximum is attained in <span class="math inline">x = 0</span> and <span class="math inline">g_1'(0) \leq 0</span> . Show yourself that <span class="math inline">x = 8/9</span> is indeed a solution to <span class="math inline">g_1'(x) = 0</span>.</p>
<p>The above example shows that for a given <span class="math inline">\mu</span> we can show with elementary calculus whether or not it satisfies the definition of a pure Nash equilibrium (convince yourself that this approach also works for games with more than two miners).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.1
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider a game with three miners whose payoff functions are <span class="math display">
p_i(\mu_1,\mu_2,\mu_3) =  w_i \cdot \frac{\mu_i}{\mu_1 + \mu_2 + \mu_3} - \mu_i
</span> for <span class="math inline">i = 1,2,3</span> with <span class="math inline">w_1 = 4, w_2 = 2</span> and <span class="math inline">w_3 = 0.5</span>. Show that <span class="math inline">\mu = (8/9,4/9,0)</span> is a pure Nash equilibrium of this game (part of your solution should be to formalize the calculations above).</p>
</div>
</div>
<section id="computation-for-n-2" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="computation-for-n-2"><span class="header-section-number">8.2.1</span> Computation for <span class="math inline">n = 2</span></h3>
<p>To determine a pure Nash equilibrium of the game, we do not want to keep guessing solutions by checking the definition. Instead we want a constructive way to compute an equilibrium given the payoff functions of the miners. For a game with two miners, this is the purpose of the next exercise.</p>
<p>The reasoning in the example of the previous section can be very helpful to successfully solve the coming exercise, so make sure you understand that example.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.2
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let <span class="math inline">w_1 \geq w_2 &gt; 0</span> and consider the payoff functions <span class="math display">
p_1(\mu) = w_1 \cdot \frac{\mu_1}{\mu_1 + \mu_2} - \mu_1 \ \text{ and } \ p_2(\mu) = w_2 \cdot \frac{\mu_2}{\mu_1 + \mu_2} - \mu_2.
</span> Compute the (unique) pure Nash equilibrium <span class="math inline">\mu = (\mu_1,\mu_2)</span> of this Tullock contest by deriving explicit formulas for <span class="math inline">\mu_1 = \mu_1(w_1,w_2)</span> and <span class="math inline">\mu_2 = \mu_2(w_1,w_2)</span>, i.e., the equilibrium hash rates in terms of <span class="math inline">w_1</span> and <span class="math inline">w_2</span>. You can use the following steps for this:</p>
<ol type="1">
<li>Show that if one or both of the <span class="math inline">\mu_i</span> equal zero, then <span class="math inline">\mu = (\mu_1,\mu_2)</span> cannot be a pure Nash equilibrium. <em>Recall that a best response for miner <span class="math inline">i</span> is to choose a (small) hash rate of <span class="math inline">\delta &gt; 0</span> when all other miners have hash rate <span class="math inline">0</span> (see remark under PNE definition).</em></li>
<li>Argue next that <span class="math inline">\mu</span> is a pure Nash equilibrium if and only if the following <em>first-order conditions</em> are satisfied: <span class="math display">
\frac{\partial p_1}{\partial \mu_1}(\mu) = 0 \ \text{ and }\  \frac{\partial p_2}{\partial \mu_2}(\mu) = 0.
</span></li>
<li>Solve the first-order conditions for <span class="math inline">\mu_1</span> and <span class="math inline">\mu_2</span> in terms of <span class="math inline">w_1</span> and <span class="math inline">w_2</span>.</li>
</ol>
</div>
</div>
</section>
<section id="computation-for-n-2-1" class="level3" data-number="8.2.2">
<h3 data-number="8.2.2" class="anchored" data-anchor-id="computation-for-n-2-1"><span class="header-section-number">8.2.2</span> Computation for <span class="math inline">n &gt; 2</span></h3>
<p>The approach above can be extended to games with more than two miners. There even exists a closed-form solution for the (unique) pure Nash equilibrium. We do not go into this exact closed-form solution, but we give a short sketch of how to obtain the equilibrium for <span class="math inline">n</span> miners. We will assume that <span class="math inline">w_1 \geq w_2 \geq \dots \geq v_n</span>. You can do this without loss of generality by renumbering the miners if needed.</p>
<p>First, it can be argued (just as we did in the exercise above) that in a pure Nash equilibriu <span class="math inline">\mu</span> at least two entries must be strictly positive. This implies that for every <span class="math inline">i</span>, the quantity <span class="math inline">\sum_{j \neq i} \mu_j &gt; 0</span> (do you understand why)?</p>
<p>Second, the pure Nash equilibrium <span class="math inline">\mu</span> must satisfy the first order conditions <span class="math display">
\left\{
\begin{array}{ll}
\frac{\partial p_i}{\partial \mu_i}(\mu) = 0 &amp; \text{ if } \mu_i &gt; 0 \\[1ex]
\frac{\partial p_i}{\partial \mu_i}(0) \leq 0 &amp; \text{ if } \mu_i = 0
\end{array}
\right.
</span> That is, if <span class="math inline">\mu_i &gt; 0</span> then it is an internal maximizer of the best response function <span class="math inline">g_i</span>, and if <span class="math inline">\mu_i = 0</span>, then it must be that the best response function is decreasing, which is equivalent to the derivative in zero being nonnegative; the concavity of <span class="math inline">g_i</span> then implies that the function is decreasing on <span class="math inline">[0,\infty)</span>.</p>
<p>The problem now is that we do not know <em>a priori</em> which <span class="math inline">\mu_i</span>’s will be zero, and which will be strictly great than zero. It turns out, though, that there is some nice structure in this regard: If <span class="math inline">w_i \geq w_j</span> and <span class="math inline">\mu_i = 0</span>, then also <span class="math inline">\mu_j = 0</span> (this is a somewhat tricky calculus exercise). Recall that we assumed that <span class="math inline">w_1 \geq w_2 \geq \dots \geq w_n</span>. This means that in the pure Nash equilibrium, if one or more miners have <span class="math inline">\mu_i = 0</span>, then there exists an index <span class="math inline">\hat{n}</span> such that all zeros in the equilibrium are attained for indices <span class="math inline">i = \hat{n}+1,\dots,n</span>, i.e., the equilibrium is of the form <span class="math display">
\mu = (\mu_1,\dots,\mu_{\hat{n}},0,0,\dots,0).
</span></p>
<p>There exists an explicit formula known for <span class="math inline">\hat{n}</span>, namely <span id="eq-hat_n"><span class="math display">
\hat{n} = \max\left\{i \in [n] : w_i &gt; \frac{i-2}{\sum_{j=1}^{i-1} \frac{1}{w_j}} \right\}.
\tag{8.1}</span></span> In other words, <span class="math inline">\hat{n}</span> is the largest index <span class="math inline">i</span> for which the inequality <span class="math inline">w_i &gt; \frac{i-2}{\sum_{j=1}^{i-1} \frac{1}{w_j}}</span> holds. We use the convention that <span class="math inline">\sum_{j=1}^0  \frac{1}{w_j} = 1</span>.</p>
<p>Note that <span class="math inline">\hat{n}</span> can be computed using only the input parameters <span class="math inline">w_1, \dots, w_n</span> of the Tullock contest. Also observe that we always have <span class="math inline">\hat{n} \geq 2</span>, because we assume the <span class="math inline">w_i</span> to be strictly positive. This correspond with the fact that in a pure Nash equilibrium, there will always be at least two miners with a strictly positive hash rate. Proving the correctness of the formula for <span class="math inline">\hat{n}</span> requires some nontrivial arguments, that we omit here.</p>
<p>The remaining (strictly positive) values of <span class="math inline">\mu_1,\dots,\mu_{\hat{n}}</span> can be determined by solving the system of equations <span id="eq-system-positive"><span class="math display">
\frac{\partial p_i}{\partial \mu_i}(\mu) = 0 \ \text{ for } \ i = 1,\dots,\hat{n}
\tag{8.2}</span></span> with <span class="math inline">\mu_{\hat{n}+1} = \dots = \mu_n = 0</span> substituted in these equations. This leaves a (non-linear) system of <span class="math inline">\hat{n}</span> equalities with <span class="math inline">\hat{n}</span> unknown variables.</p>
<p>“Solving” this system means that we would like to express the <span class="math inline">\mu_i</span> as a function of the input parameters <span class="math inline">w_1,\dots,w_n</span>, just as we did in the exercise earlier in this section with <span class="math inline">n = 2</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.3
</div>
</div>
<div class="callout-body-container callout-body">
<p>This exercise is dedicated to solving the system of equations in <a href="#eq-system-positive" class="quarto-xref">Equation&nbsp;<span>8.2</span></a> to determine the strictly positive <span class="math inline">\mu_i</span> in the pure Nash equilibrium.</p>
<ol type="1">
<li>Show that the system in <a href="#eq-system-positive" class="quarto-xref">Equation&nbsp;<span>8.2</span></a> is equivalent to the equations <span class="math display">
\mu_i = \left(\sum_{j=1}^{\hat{n}} \mu_j\right)  - \frac{1}{w_i} \left(\sum_{j=1}^{\hat{n}} \mu_j\right)^2 \ \text{ for } i = 1,\dots,\hat{n}
</span></li>
<li>Define <span class="math inline">\lambda = \sum_{j=1}^{\hat{n}} \mu_j</span>. Determine an equation for <span class="math inline">\lambda</span> by adding up all the equations of part 1.</li>
<li>Solve the resulting equation for <span class="math inline">\lambda</span> to show that <span class="math display">
\lambda = \lambda(w_1,\dots,w_n) = \frac{\hat{n} - 1}{\sum_{j=1}^{\hat{n}} \frac{1}{w_j}}.
</span></li>
</ol>
<p>Note that we can then finally express the <span class="math inline">\mu_i</span> as a function of <span class="math inline">w_1,\dots,w_n</span> (through <span class="math inline">\lambda</span>) by <span class="math display">
\mu_i = \lambda - \frac{1}{w_i}\lambda^2
</span> for <span class="math inline">i = 1,\dots,\hat{n}</span>.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.4
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the Tullock contest with <span class="math inline">w_1 = 4, w_2 = 2, w_3 = 0.5</span> and <span class="math inline">w_4 = 0.2</span>. Compute the value of <span class="math inline">\hat{n}</span> and use the formulas of the previous exercise to show that <span class="math inline">\mu = (8/9,4/9,0,0)</span> is the pure Nash equilibrium of this game (i.e., compute <span class="math inline">\lambda</span> and then <span class="math inline">\mu_1</span> and <span class="math inline">\mu_2</span> using <span class="math inline">\lambda</span>).</p>
</div>
</div>
<p>To summarize, we have the following theorem.</p>
<div id="thm-equilibrium-computation" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8.1 (Equilibrium computation with <span class="math inline">n</span> miners.)</strong></span> Let <span class="math inline">w_1 \geq \dots \geq w_n &gt; 0</span> and <span class="math display">
\hat{n} = \max\left\{i \in [n] : w_i &gt; \frac{i-2}{\sum_{j=1}^{i-1} \frac{1}{w_j}} \right\}.
</span> Then the (unique) pure Nash equilibrium <span class="math inline">\mu = (\mu_1,\dots,\mu_n)</span> of the Tullock contest is given by <span class="math display">
\mu_i = \left\{
\begin{array}{ll}
\lambda - \frac{1}{w_i}\lambda^2 &amp; \text{ for } i \leq \hat{n} \\
0 &amp; \text{ for } i &gt; \hat{n}
\end{array}
\right. \ \ \text{ with } \ \ \ \lambda = \frac{\hat{n} - 1}{\sum_{j=1}^{\hat{n}} \frac{1}{w_j}}.
</span></p>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.5
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the Tullock contest with <span class="math inline">w_1 = w_2 = \dots = w_n = w</span>. Use <a href="#thm-equilibrium-computation" class="quarto-xref">Theorem&nbsp;<span>8.1</span></a> to show that its pure Nash equilibrium is given by <span class="math inline">\mu = (\mu_1,\dots,\mu_n)</span> with <span class="math display">
\mu_i = \frac{n-1}{n^2}w
</span> for <span class="math inline">i = 1,\dots,n</span>. This is called a <em>symmetric</em> pure Nash equilibrium, because all <span class="math inline">\mu_i</span> are the same.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.6
</div>
</div>
<div class="callout-body-container callout-body">
<p>We will derive a concise expression for the market share <span class="math inline">x_i(\mu)  = \mu_i/(\sum_j \mu_j)</span> of miner <span class="math inline">i</span> in the pure Nash equilibrium.</p>
<ol type="1">
<li>Show that <span class="math inline">x_i(\mu) = 1 - \frac{1}{w_i}\lambda</span> for <span class="math inline">i = 1,\dots,\hat{n}</span> with <span class="math inline">\lambda</span> as in <a href="#thm-equilibrium-computation" class="quarto-xref">Theorem&nbsp;<span>8.1</span></a>.</li>
<li>Based on part 1., show that<br>
<span class="math display">
x_i(\mu) = \max\left\{0,1 -  \frac{1}{w_i}\lambda\right\}
</span> for <span class="math inline">i = 1,\dots,n</span>.</li>
</ol>
</div>
</div>
</section>
</section>
<section id="best-response-dynamics" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="best-response-dynamics"><span class="header-section-number">8.3</span> Best response dynamics</h2>
<p>We conclude this chapter with some remarks about best response dynamics. Formally, such dynamics are defined as an iterative process where in every iteration, given a hash rate profile <span class="math inline">\mu = (\mu_1,\dots,\mu_n)</span> one miner <span class="math inline">i</span> gets to compute their best response against <span class="math inline">\mu_{-i}</span>, i.e., maximize their best response function <span class="math inline">g_i(x) = p_i(x,\mu_{-i}).</span> We keep repeating this procedure until no miner wants to change their hash rate anymore.</p>
<p>By solving the first order conditions, and recalling that the best response to the all-zeros vector <span class="math inline">\mu_{-i} = (0,\dots,0)</span> is a small number <span class="math inline">\delta</span>, we can express the best response of miner <span class="math inline">i</span> given <span class="math inline">\mu_{-i}</span> as <span class="math display">
\text{BR}_i(\mu_{-i}) = \left\{
\begin{array}{ll}
\delta &amp; \text{ if } \sum_{j \neq i} \mu_j = 0 \\
\sqrt{w_i(\sum_{j \neq i} \mu_j)} - \sum_{j \neq i} \mu_j &amp; \text{ if } 0 &lt; \sum_{j\neq i} \mu_j &lt; w_i \\
0 &amp; \text{ if } \sum_{j \neq i} \mu_j \geq w_i
\end{array}
\right.
</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.7
</div>
</div>
<div class="callout-body-container callout-body">
<p>Verify the correctness of the formula for <span class="math inline">\text{BR}_i</span> above.</p>
</div>
</div>
<p>We will assume the iterative process is done in a <em>round-robin</em> fashion, that is, we iterate over miners <span class="math inline">1,\dots,n</span> and then start at miner <span class="math inline">1</span> again. More precisely, the miner updating their best response in round <span class="math inline">t</span> is <span class="math inline">i = t \text{ mod } n</span>. The pseudo-code of best response dynamics is therefore as follows.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Best response dynamics</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>1.  Initialize </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    - Weight vector w = [w_1,..,w_n] </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    - Initial hash rate vector mu = [mu_1,...,mu_n]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    - Number of rounds T</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    - Parameter delta (best response against all-zeros vector).</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>2.  In each round t = 1,2,3,...,T do:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    - Compute best response of miner i = t (mod n)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    - Update value mu_i with the computed best response</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A Python implementation of this procedure with <span class="math inline">n = 4</span> miners is given below with</p>
<ul>
<li><span class="math inline">w = (5, 2, 0.5, 0.2)</span></li>
<li><span class="math inline">\mu = (1,1,1,1)</span></li>
<li><span class="math inline">T = 40</span></li>
<li><span class="math inline">\delta = 1/(w_{\max}\cdot n^3) \approx 0.0039</span> (any small enough number is allowed here).</li>
</ul>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="3c79d7dd" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Show code for executing best response dynamics</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Weight vector</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([<span class="dv">4</span>, <span class="dv">2</span>, <span class="fl">0.5</span>, <span class="fl">0.2</span>])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of miners</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> np.size(w)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial hash rate vector</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([<span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of best response iterations</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Value of delta (brd against all-zeros vector)</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(np.<span class="bu">max</span>(w)<span class="op">*</span>n<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Function that computes best response for miner i given hash rate vector mu</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> best_response(i, mu, wi, delta):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    rate_minus_i <span class="op">=</span> np.<span class="bu">sum</span>(mu) <span class="op">-</span> mu[i]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.allclose(rate_minus_i, <span class="dv">0</span>):  <span class="co"># First BRD case</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> delta</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> (rate_minus_i <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> (rate_minus_i <span class="op">&lt;=</span> wi):  <span class="co"># Second BRD case</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> np.sqrt(wi <span class="op">*</span> rate_minus_i) <span class="op">-</span> rate_minus_i</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> rate_minus_i <span class="op">&gt;</span> wi:  <span class="co"># Third BRD case</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> br</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Executing best response dynamics procedure</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> best_response_dynamics(w,mu,T,delta):</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create an empty list to store the results</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    mu_history <span class="op">=</span> []</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Append initial hash rate vector to results list</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    mu_history.append(mu.copy())</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T):</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.mod(t, n)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        mu[i] <span class="op">=</span> best_response(i, mu, w[i], delta)    </span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        mu_history.append(mu.copy())  <span class="co"># Append hash rate vector to results list</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the mu_history list to a pandas DataFrame</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    mu_df <span class="op">=</span> pd.DataFrame(mu_history, columns<span class="op">=</span>[<span class="ss">f'mu_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add an "Iteration" column for the index</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>    mu_df.insert(<span class="dv">0</span>, <span class="st">'Iteration'</span>, np.arange(T <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display the DataFrame without the index column</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> mu_df.to_string(index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>brd <span class="op">=</span> best_response_dynamics(w,mu,T,delta)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(brd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> Iteration     mu_1     mu_2     mu_3  mu_4
         0 1.000000 1.000000 1.000000   1.0
         1 0.464102 1.000000 1.000000   1.0
         2 0.464102 0.000000 1.000000   1.0
         3 0.464102 0.000000 0.000000   1.0
         4 0.464102 0.000000 0.000000   0.0
         5 0.003906 0.000000 0.000000   0.0
         6 0.003906 0.084482 0.000000   0.0
         7 0.003906 0.084482 0.121836   0.0
         8 0.003906 0.084482 0.121836   0.0
         9 0.702127 0.084482 0.121836   0.0
        10 0.702127 0.459753 0.121836   0.0
        11 0.702127 0.459753 0.000000   0.0
        12 0.702127 0.459753 0.000000   0.0
        13 0.896349 0.459753 0.000000   0.0
        14 0.896349 0.442568 0.000000   0.0
        15 0.896349 0.442568 0.000000   0.0
        16 0.896349 0.442568 0.000000   0.0
        17 0.887948 0.442568 0.000000   0.0
        18 0.887948 0.444680 0.000000   0.0
        19 0.887948 0.444680 0.000000   0.0
        20 0.887948 0.444680 0.000000   0.0
        21 0.889006 0.444680 0.000000   0.0
        22 0.889006 0.444415 0.000000   0.0
        23 0.889006 0.444415 0.000000   0.0
        24 0.889006 0.444415 0.000000   0.0
        25 0.888874 0.444415 0.000000   0.0
        26 0.888874 0.444448 0.000000   0.0
        27 0.888874 0.444448 0.000000   0.0
        28 0.888874 0.444448 0.000000   0.0
        29 0.888891 0.444448 0.000000   0.0
        30 0.888891 0.444444 0.000000   0.0
        31 0.888891 0.444444 0.000000   0.0
        32 0.888891 0.444444 0.000000   0.0
        33 0.888889 0.444444 0.000000   0.0
        34 0.888889 0.444445 0.000000   0.0
        35 0.888889 0.444445 0.000000   0.0
        36 0.888889 0.444445 0.000000   0.0
        37 0.888889 0.444445 0.000000   0.0
        38 0.888889 0.444444 0.000000   0.0
        39 0.888889 0.444444 0.000000   0.0
        40 0.888889 0.444444 0.000000   0.0</code></pre>
</div>
</div>
<p>In the output above we can see that the vector <span class="math inline">\mu</span> seems to converge to <span class="math inline">(8/9,4/9,0,0)</span> which was indeed the PNE that we saw earlier in this chapter for this specific choice of weight vector <span class="math inline">w</span> (see Exercise <span class="math inline">8.4</span>). It should be noted though, that we never <em>exactly</em> reach this vector <span class="math inline">\mu</span>. The dynamics converges to the PNE over time, but does not attain it in a finite number of iterations.</p>
<p>To deal with this, we can look at a relaxed equilibrium notion, called the <em><span class="math inline">\epsilon</span>-approximate pure Nash equilibrium (<span class="math inline">\epsilon</span>-PNE)</em>. Intuitively, if <span class="math inline">\mu</span> is an <span class="math inline">\epsilon</span>-PNE then some miners might have an incentive to deviate, but the improvement in payoff that this will give them is at most an additive term <span class="math inline">\epsilon</span>. Note that a pure Nash equilibrium is an <span class="math inline">\epsilon</span>-PNE for <span class="math inline">\epsilon = 0</span>.</p>
<div id="def-epsilon-pne" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 8.2 (<span class="math inline">\epsilon</span>-approximate Pure Nash equilibrium)</strong></span> A hash rate vector <span class="math inline">\mu</span> is an <span class="math inline">\epsilon</span>-approximate pure Nash equilibrium (PNE) if for all <span class="math inline">i = 1,\dots,n</span>, it holds that <span class="math display">
p_i(\mu) \geq p_i(\mu_i',\mu_{-i}) - \epsilon
</span> for all <span class="math inline">\mu_i' \geq 0</span>.</p>
</div>
<!--
:::{.callout-tip}
# Exercise 8.8

[TWO EXERCISES ABOUT DETERMINING THE SMALLEST EPSILON FOR WHICH A GIVEN HASH RATE VECTOR IS AN EPSILON NASH EQUILIBRIUM]
:::
-->
<p>We can now instead run the dynamics until an <span class="math inline">\epsilon</span>-PNE is found. The updated pseudo-code is given below.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Best response dynamics for computing epsilon-PNE</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>1.  Initialize </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    - Weight vector w = [w_1,..,w_n] </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    - Initial hash rate vector mu = [mu_1,...,mu_n]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    - Number of rounds T</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    - Parameter delta (best response against all-zeros vector).</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    - Parameter epsilon</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>2.  While mu is not an epsilon-PNE, do:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    - Compute best response of miner i = t (mod n)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    - Update value mu_i with the computed best response</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In general, best response dynamics are not guaranteed to converge to an (<span class="math inline">\epsilon</span>-)PNE. This means that the while-loop in the pseudo-code above is not guaranteed to terminate. Let us look at such an example with two miners and <span class="math inline">\epsilon = 0</span>.</p>
<div id="cf258fe3" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Weight vector</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="dv">1</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of miners</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> np.size(w)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of best response iterations</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Value of delta (best reponse against all-zeros vector)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> <span class="dv">10</span><span class="op">**</span>(<span class="op">-</span><span class="dv">5</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial hash rate vector</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([<span class="dv">0</span>,delta])</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Function best_response_dynamics() is defined in previous snippet</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>brd <span class="op">=</span> best_response_dynamics(w,mu,T,delta)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(brd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> Iteration     mu_1     mu_2
         0 0.000000 0.000010
         1 0.000990 0.000010
         2 0.000990 0.030474
         3 0.024729 0.030474
         4 0.024729 0.132526
         5 0.000000 0.132526
         6 0.000000 0.000010
         7 0.000990 0.000010
         8 0.000990 0.030474
         9 0.024729 0.030474
        10 0.024729 0.132526
        11 0.000000 0.132526
        12 0.000000 0.000010</code></pre>
</div>
</div>
<p>After <span class="math inline">t = 6</span> iterations we are back at the hash rate vector that we started with! And so, the best response dynamics keeps cycling through the first six hash rate vectors in the above list without ever approaching the PNE of the game.</p>
<p>This means we have to reflect a bit on what we did before. We studied the pure Nash equilibrium as “natural” outcome of the best response dynamics process, but the dynamics is not guaranteed to end up there! Despite the existence of examples where the best response dynamics does not converge, it does converge in many cases, though.</p>
<p>One class where best response dynamics are guaranteed to converge is when the miners have a common value <span class="math inline">w_1 = \dots = w_n = w</span> as in the symmetric setting we considered in Exercise 8.6. For simplicity, we will set <span class="math inline">w = 1</span>. The common payoff function of all miners <span class="math inline">i = 1,\dots,n</span> is then <span class="math display">
p_i(\mu) = \frac{\mu_i}{\sum_j \mu_j} - \mu_i.
</span></p>
<section id="potential-function" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="potential-function"><span class="header-section-number">8.3.1</span> Potential function</h3>
<p>We can use a <em>(best response) potential function argument</em> to show that best response dynamics always converge under equal payoff functions. The idea of such an argument is to construct a (bounded from above) function <span class="math inline">P : \mathbb{R}^n_{\geq 0} \rightarrow \mathbb{R}</span> that takes as input a hash rate vector <span class="math inline">\mu = (\mu_1,\dots,\mu_n)</span> and outputs a real number. Bounded from above here means that there exists a constant <span class="math inline">c \in \mathbb{R}</span> such that <span class="math inline">P(\mu) \leq c</span> for all <span class="math inline">\mu \in \mathbb{R}^n_{\geq 0}</span>.</p>
<p>The function <span class="math inline">P</span> will be constructed in such a way that if a miner <span class="math inline">i</span> makes a best response move in <span class="math inline">\mu = (\mu_1,\dots\mu_{i-1},\mu_{i},\mu_{i+1},\mu_n) = (\mu_i,\mu_{-i})</span> to <span class="math inline">\mu' =  (\mu_1,\dots\mu_{i-1},\mu_{i}',\mu_{i+1},\mu_n) = (\mu_i',\mu_{-i})</span>, i.e, miner <span class="math inline">i</span> unilaterally deviates from <span class="math inline">\mu_i</span> to <span class="math inline">\mu_i'</span>, then the value of <span class="math inline">P(\mu')</span> will be higher than <span class="math inline">P(\mu)</span>. In other words, whenever a miner makes a best response move, the value of the potential function goes up.</p>
<p>Because <span class="math inline">P</span> is bounded from above, the intuition is that if we perform enough best response rounds, and increase the potential function value in every round a little bit, then we must get close to an (approximate) pure Nash equilibrium in a finite number of steps, because the potential function is bounded from above and so it cannot increase indefinitely. There is a small caveat in this reasoning, which is that the increments might get smaller and smaller (as we saw in one of the examples above as well), so we need to guarantee that enough “progress” is made in every round. We will get back to this last point later on.</p>
<p>For now, let us look at a potential function that has the property that its value increases whenever a miner makes a best response move. To find such a function, you typically have to make an educated guess and show that it does what it needs to do. In our setting, we can define <span class="math display">
P(\mu) = -\frac{1}{3}\left(\sum_{i=1}^n \mu_i\right)^3 + \sum_{i &lt; j } \mu_i\mu_j
</span> as the potential function. As an example, for <span class="math inline">n = 3</span>, we have <span class="math display">
P(\mu) = -\frac{1}{3}\left(\mu_1 + \mu_2 + \mu_3\right)^3 + \mu_1\mu_2 + \mu_1\mu_3 + \mu_2\mu_3.
</span></p>
<p>We have to address one technicality with respect to the domain of the function <span class="math inline">P</span>. Recall that, to avoid limit arguments, we define the best response of a miner <span class="math inline">i</span> to be a small (fixed) number <span class="math inline">\delta</span> whenever the hash rates of all the other miners are zero in <span class="math inline">\mu</span>. To deal with this appropriately in the potential function <span class="math inline">P</span>, we formally define <span class="math inline">P</span> as a function <span class="math inline">P : \mathbb{R}^n_{\geq 0} \setminus (\cup_{i=1}^n Z_i) \rightarrow \mathbb{R}</span> where for <span class="math inline">i = 1,\dots,n</span>, <span class="math display">
Z_i = \{ (0,\dots,0,\mu_i,0,\dots,0) : 0 \leq \mu_i &lt; \delta \}.
</span> That is, we do not allow hash rate vectors <span class="math inline">\mu</span> with one non-zero entry that is smaller than <span class="math inline">\delta</span>.</p>
<p>We first show that the function <span class="math inline">P</span> is indeed bounded from above.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.9
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that <span class="math inline">P(\mu) \leq \frac{2}{3}</span> for all <span class="math inline">\mu \in \mathbb{R}^n_{\geq 0}</span>. <em>Hint: Use that <span class="math inline">\sum_{i &lt;j} x_ix_j \leq (\sum_i x_i)^2</span> and then the substitution <span class="math inline">y = \sum_i x_i</span></em>.</p>
</div>
</div>
<p>In fact, we can show a stronger result, namely that <span class="math inline">P</span> has a global maximizer. Recall that in Exercise 8.5, we showed that the PNE <span class="math inline">\mu</span> of a symmetric Tullock contest is given by <span class="math inline">\mu_i = (n-1)/n^2</span> for <span class="math inline">i = 1,\dots,n</span> if <span class="math inline">w = 1</span>. It can be shown that this <span class="math inline">\mu</span> is the global maximizer of <span class="math inline">P</span> over its formal domain, as well as over <span class="math inline">\mathbb{R}^n_{\geq 0}</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.10
</div>
</div>
<div class="callout-body-container callout-body">
<p>For <span class="math inline">n = 2</span>, show that <span class="math inline">\mu = (\frac{1}{4},\frac{1}{4})</span> is the global maximizer of <span class="math display">
P(\mu) = -\frac{1}{3}\left(\mu_1 + \mu_2 \right)^3 + \mu_1\mu_2
</span> on <span class="math inline">\mathbb{R}^{2}</span> by executing the following steps (that together analyse <span class="math inline">P</span> on the whole of <span class="math inline">\mathbb{R}^2</span>):</p>
<ol type="1">
<li>Show that <span class="math inline">P(\mu) \leq 0</span> for all <span class="math inline">\mu \in \{ (\mu_1,\mu_2) : \mu_1 + \mu_2 &gt; 3, \mu_1, \mu_2 \geq 0\}</span>.</li>
<li>Show that <span class="math inline">P(\mu) \leq 0</span> on the boundary of the set <span class="math display">
D = \{ (\mu_1,\mu_2) : \mu_1 + \mu_2 \leq 3, \mu_1, \mu_2 \geq 0\}.
</span></li>
<li>Show that in the interior of <span class="math inline">D</span>, we have<br>
<span class="math display">
\nabla P =  \left( \frac{\partial P}{\partial \mu_1}, \frac{\partial P}{\partial \mu_2}\right) = (0,0)
</span> if and only if <span class="math inline">\mu = (\frac{1}{4},\frac{1}{4})</span>.</li>
</ol>
<p>Conclude from the above three steps that <span class="math inline">\mu = (\frac{1}{4},\frac{1}{4})</span> is indeed the global maximizer of <span class="math inline">P</span>.</p>
</div>
</div>
<p>With a bit more effort, the above exercise can be generalized to an arbitrary value of <span class="math inline">n</span> (feel free to try this yourself).</p>
<p>Now comes the most important part: We want to show that if a miner makes a best response, then the potential function increases. This is summarized in the following theorem, that states that doing a single-variable optimization of <span class="math inline">P</span> over <span class="math inline">\mu_i</span> yields the same optimal point as computing a best response of miner <span class="math inline">i</span>.</p>
<div id="thm-brd-potential" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8.2 (Best response potential function)</strong></span> Let <span class="math inline">w_1 = \dots = w_n = 1</span> so that the common payoff function of miners <span class="math inline">i = 1,\dots,n</span> is given by <span class="math display">
p_i(\mu) = \frac{\mu_i}{\sum_j \mu_j} - \mu_i.
</span> Then for any <span class="math inline">\mu \in \mathbb{R}^n_{\geq 0} \setminus (\cup_{i=1}^n Z_i)</span>, it holds that <span class="math display">
\text{argmax}_{x \geq 0} P(x,\mu_{-i}) = \text{argmax}_{x \geq 0} p_i(x,\mu_{-i}).
</span></p>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.11
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that for a given fixed <span class="math inline">\mu_{-i}</span>, it holds that <span class="math display">
\text{argmax}_{x \geq 0} P(x,\mu_{-i}) = \left\{
\begin{array}{ll}
\delta &amp; \text{ if } \sum_{j \neq i} \mu_j = 0 \\
\sqrt{\sum_{j \neq i} \mu_j} - \sum_{j \neq i} \mu_j &amp; \text{ if } 0 &lt; \sum_{j\neq i} \mu_j &lt; 1 \\
0 &amp; \text{ if } \sum_{j \neq i} \mu_j \geq 1
\end{array}
\right.
</span> which shows that <span class="math inline">\text{argmax}_{x \geq 0} P(x,\mu_{-i})</span> is the same function as <span class="math inline">\text{BR}_i(\mu_{-i}) = \text{argmax}_{x \geq 0} p_i(x,\mu_{-i})</span>, and thereby proves <a href="#thm-brd-potential" class="quarto-xref">Theorem&nbsp;<span>8.2</span></a>.</p>
</div>
</div>
<p>Let us finally illustrate that the function <span class="math inline">P</span> indeed increases by considering a small example of best response dynamics with initial hash rate vector <span class="math inline">\mu = (2,3)</span>. Recall that <span class="math inline">w_1 = w_2 = 1</span>.</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="ce3e3ba5" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Show code for best response dynamics with potential function values</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Weight vector</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of miners</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> np.size(w)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial hash rate vector</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.array([<span class="fl">2.0</span>,<span class="fl">3.0</span>])</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of best response iterations</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Value of delta (brd against all-zeros vector)</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>(np.<span class="bu">max</span>(w)<span class="op">*</span>n<span class="op">**</span><span class="dv">3</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Function that computes best response for miner i</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> best_response(i, mu, wi, delta):</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    rate_minus_i <span class="op">=</span> np.<span class="bu">sum</span>(mu) <span class="op">-</span> mu[i]</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.allclose(rate_minus_i, <span class="dv">0</span>):  </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> delta</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> (rate_minus_i <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> (rate_minus_i <span class="op">&lt;=</span> wi): </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> np.sqrt(wi <span class="op">*</span> rate_minus_i) <span class="op">-</span> rate_minus_i</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> rate_minus_i <span class="op">&gt;</span> wi:  </span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        br <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> br</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to compute P(mu)</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_P(mu):</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="dv">3</span> <span class="op">*</span> (mu[<span class="dv">0</span>] <span class="op">+</span> mu[<span class="dv">1</span>])<span class="op">**</span><span class="dv">3</span> <span class="op">+</span> mu[<span class="dv">0</span>] <span class="op">*</span> mu[<span class="dv">1</span>]</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Executing best response dynamics procedure</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> best_response_dynamics(w, mu, T, delta):</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create an empty list to store the results</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    mu_history <span class="op">=</span> []</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    P_history <span class="op">=</span> []</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Append initial hash rate vector to results list</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    mu_history.append(mu.copy())</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    P_history.append(compute_P(mu))</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(T):</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> np.mod(t, n)</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>        mu[i] <span class="op">=</span> best_response(i, mu, w[i], delta)    </span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>        mu_history.append(mu.copy()) </span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>        P_history.append(compute_P(mu))</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert the mu_history and P_history lists to a pandas DataFrame</span></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>    mu_df <span class="op">=</span> pd.DataFrame(mu_history, </span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>                            columns<span class="op">=</span>[<span class="ss">f'mu_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add an "Iteration" column for the index</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>    mu_df.insert(<span class="dv">0</span>, <span class="st">'Iteration'</span>, np.arange(T <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add P(mu) as an extra column</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    mu_df[<span class="st">'P(mu)'</span>] <span class="op">=</span> P_history</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display the DataFrame without the index column</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> mu_df.to_string(index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>brd <span class="op">=</span> best_response_dynamics(w, mu, T, delta)</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(brd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> Iteration     mu_1     mu_2      P(mu)
         0 2.000000 3.000000 -35.666667
         1 0.000000 3.000000  -9.000000
         2 0.000000 0.125000  -0.000651
         3 0.228553 0.125000   0.013838
         4 0.228553 0.249519   0.020607
         5 0.250000 0.249519   0.020833</code></pre>
</div>
</div>
</section>
<section id="convergence-to-epsilon-pne" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2" class="anchored" data-anchor-id="convergence-to-epsilon-pne"><span class="header-section-number">8.3.2</span> Convergence to <span class="math inline">\epsilon</span>-PNE</h3>
<p>Now that we now that the potential function value increases in ever round of the best response dynamics, what is left is to argue that the dynamics reaches a hash rate vector that comes close to the global maximizer of <span class="math inline">P</span>, which is the PNE of the Tullock contest.</p>
<p>This turns out to be a highly nontrivial task, but some results are known in the literature on Tullock contests. Here we (informally) mention one such a result.</p>
<div id="thm-brd-convergence" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8.3 (Ghosh and Golberg, 2023)</strong></span> Consider an initial hash rate vector <span class="math inline">\bar{\mu}</span> and let <span class="math inline">\epsilon &gt; 0</span>. Then best response dynamics for <span class="math inline">n = 2</span> miners with <span class="math inline">w_1 = w_2 = 1</span> reaches an <span class="math inline">\epsilon</span>-PNE in at most <span class="math display">
T = \log_2\left(\log_2\left(\frac{1}{\epsilon}\right)\right) + C_{\bar{\mu}}
</span> rounds, where <span class="math inline">C_{\bar{\mu}}</span> is a constant number depending on <span class="math inline">\bar{\mu}</span>, but independent of <span class="math inline">\epsilon</span>.</p>
</div>
<p>Note that this means the convergence goes quite quickly with respect to <span class="math inline">\epsilon</span>. For example, for <span class="math inline">\epsilon = 10^{-10}</span> we have <span class="math inline">\log_2(\log_2(1/\epsilon)) \approx 5</span>. The proof of Ghosh and Golberg (2023) makes use of the best response potential function <span class="math inline">P</span> that we introduced, but the analysis is very involved and beyond the scope of this course.</p>
</section>
</section>
<section id="two-model-variations" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="two-model-variations"><span class="header-section-number">8.4</span> Two model variations</h2>
<p>In this section we will study extensions of the basic Tullock contest, in which the payoff functions are of the form <span class="math display">
p_i(\mu) = u_i\left(\frac{\mu_i}{\sum_j \mu_j}\right) - \mu_i
</span> where the <span class="math inline">u_i: \mathbb{R}_{\geq 0} \rightarrow \mathbb{R}</span> are given functions for <span class="math inline">i = 1,\dots,n</span>.</p>
<p>We will first consider the setting where the <span class="math inline">u_i</span> are concave functions, modeling risk averse miners as in <a href="07-proportional-rule.html#sec-risk-averse" class="quarto-xref"><span>Section 7.3</span></a>. We will also consider a case corresponding to a so-called <em>economy of scale</em>. Here we provide some evidence why there tend to be only a couple of “big players” in the mining contest.</p>
<section id="concave-utilities" class="level3" data-number="8.4.1">
<h3 data-number="8.4.1" class="anchored" data-anchor-id="concave-utilities"><span class="header-section-number">8.4.1</span> Concave utilities</h3>
<p>In this section we assume that the utility function of miner <span class="math inline">i</span> is given by <span class="math display">
p_i(\mu) = u_i\left(\frac{\mu_i}{\sum_j \mu_j}\right) - \mu_i
</span> with <span class="math inline">u_i</span> a strictly increasing, concave function with <span class="math inline">u_i(0) = 0</span> for <span class="math inline">i = 1,\dots,n</span>.</p>
<p>Also for these payoff functions, we make the assumption that a best response of miner <span class="math inline">i</span> against the all-zeros hash rate vector is a sufficiently small number <span class="math inline">\delta &gt; 0</span>. For our purposes below, it will be sufficient to choose <span class="math inline">\delta = 10^{-1}\cdot \min_i u_i(\frac{1}{2})</span>. Note that <span class="math inline">\delta &gt; 0</span> because we assume <span class="math inline">u_i(0) = 0</span> and <span class="math inline">u_i</span> to be strictly increasing.</p>
<p>Tullock contests of this form still have a pure Nash equilibrium, but it can no longer be explicitly computed as in <a href="#thm-equilibrium-computation" class="quarto-xref">Theorem&nbsp;<span>8.1</span></a>, nor is a potential function known (whose maximizer is the pure Nash equilibrium) that can be used to analyze best response dynamics for this setting.</p>
<p>Nevertheless, it turns out we can compute a PNE by solving a (concave) maximization problem!<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> To be more precise, if we define <span class="math display">
x_i = \frac{\mu_i}{\sum_j \mu_j}
</span> as the market share (or winning probability) of miner <span class="math inline">i</span>, we can determine the optimal market shares by solving an optimization problem. Because the problem turns out to be a concave maximization problem, there exist many efficient optimization algorithms that can solve this problem quickly!</p>
<p>From the solution we can also obtain the individual hash rates <span class="math inline">\mu_i</span> for <span class="math inline">i = 1,\dots,n</span>. We will discuss the second point after showing the main result for the market shares.</p>
<p>The (concave) maximization problem for determining the shares <span class="math inline">x_i</span> is given in the theorem below. We will prove its correctness by showing that the first-order conditions of a PNE correspond to the KKT conditions (see <a href="02-prelim.html#sec-prelim-concave-maximization" class="quarto-xref"><span>Section 2.4</span></a>) of the optimization problem.</p>
<div id="thm-pne-concave-utilities" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8.4 (Computing pure Nash equilibrium under concave utilities)</strong></span> Suppose that the payoff of miner <span class="math inline">i=1,\dots,n</span> is given by <span class="math display">
p_i(\mu) = u_i\left(\frac{\mu_i}{\sum_j \mu_j}\right) - \mu_i
</span> with <span class="math inline">u_i</span> a strictly increasing, concave function with <span class="math inline">u_i(0) = 0</span> for <span class="math inline">i = 1,\dots,n</span>. Then the market shares <span class="math inline">x_i = \frac{\mu_i}{\sum_j \mu_j}</span> of a pure Nash equilibrium of the resulting Tullock contest can be computed by solving the concave maximization problem <span class="math display">
\begin{array}{lll}
\displaystyle \max_{x \in \mathbb{R}^n} &amp; \displaystyle \sum_{i=1}^n \hat{u}_i(x_i) &amp; \\
\displaystyle\text{subject to} &amp; \displaystyle \sum_i x_i = 1 &amp; \\
\displaystyle &amp; x_i \geq 0 &amp; \text{ for } i = 1,\dots,n
\end{array}
</span> where for <span class="math inline">i = 1,\dots,n</span> we have <span class="math display">
\hat{u}_i(x_i) = (1-x_i)u_i(x_i) + \int_0^{x_i} u_i(z) \mathrm{d}z.
</span></p>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.12
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that <span class="math inline">\hat{u}_i(x_i) = w_ix_i\left(1 - \frac{1}{2}x_i\right)</span> for <span class="math inline">u_i(z) = w_i z</span>.</p>
</div>
</div>
<p><em>Proof of <a href="#thm-pne-concave-utilities" class="quarto-xref">Theorem&nbsp;<span>8.4</span></a>.</em> We first argue that if <span class="math inline">\mu</span> is a PNE, then at least two miners have a strictly positive hash rate. (Recall that this was also the case in the basic model in <a href="#sec-pne" class="quarto-xref"><span>Section 8.2</span></a>.)</p>
<p><strong>Claim 1:</strong> If <span class="math inline">\mu \in \mathbb{R}^n_{\geq 0}</span> is a PNE, then at least two miners have a strictly positive hash rate.</p>
<p><em>Proof of Claim 1.</em> First suppose that <span class="math inline">\mu = (0,0,0,\dots,0)</span> is the all-zeros vector. Note that then <span class="math inline">p_i(\mu) = u_i(0) - 0 = 0</span> for every <span class="math inline">i</span>. Now any fixed miner can improve their utility by playing <span class="math inline">\delta</span>. For example, if miner <span class="math inline">i = 1</span> deviates to <span class="math inline">\mu_1' = \delta</span>, we obtain <span class="math inline">p_i(\mu_1',\mu_{-1}) = u_i(1) - \delta &gt; 0</span> by our choice of <span class="math inline">\delta = 10^{-1}\cdot \min_i u_i(\frac{1}{2})</span>.</p>
<p>Second, suppose that exactly one miner <span class="math inline">i</span> has strictly positive hash rate in <span class="math inline">\mu</span>. Then this miner chooses their hash rate as small as possible, i.e., <span class="math inline">\mu_i = \delta</span>, to maximize their payoff. Now any other miner <span class="math inline">j \neq i</span> can improve their payoff by also choosing <span class="math inline">\mu_j' = \delta</span>, because then <span class="math inline">p_i(\mu_j',\mu_{-j}) = u_i(1/2) - \delta &gt; 0</span>. This means <span class="math inline">\mu</span> cannot be a best response. This completes the proof of Claim 1.</p>
<p>Note that Claim 1 implies that for every <span class="math inline">i = 1,\dots, n</span> it holds that <span class="math display">
\sum_{j \neq i} \mu_j &gt; 0.
</span></p>
<p>We will next write down the first-order conditions characterizing a pure Nash equilibrium <span class="math inline">\mu</span> and then argue that these correspond to the KKT conditions of the maximization problem in the theorem statement.</p>
<p>Note that, because <span class="math inline">u_i</span> is concave, the best response function <span class="math inline">g_i(z) = p_i(z,\mu_{-i})</span> is also concave (which is to be shown in the next exercise).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.13
</div>
</div>
<div class="callout-body-container callout-body">
<p>Assuming that <span class="math inline">\sum_{j \neq i} \mu_j &gt; 0</span>, show that the function <span class="math inline">g_i(z) = p_i(z,\mu_{-i})</span> is concave.</p>
</div>
</div>
<p>Because <span class="math inline">\lim_{z \rightarrow \infty} g_i(z) = -\infty</span> it follows that the maximum of <span class="math inline">g_i(z)</span> on <span class="math inline">[0,\infty)</span> is either attained in <span class="math inline">z = 0</span> with <span class="math inline">g_i'(0) \leq 0</span>, or at an internal maximum <span class="math inline">z</span> with <span class="math inline">g_i'(z) = 0.</span> In other words, if <span class="math inline">\mu</span> is a pure Nash equilibrium it (just as in the basic model) satisfies the first order conditions <span class="math display">
\left\{
\begin{array}{ll}
\frac{\partial p_i}{\partial \mu_i}(\mu) = 0 &amp; \text{ if } \mu_i &gt; 0 \\[1ex]
\frac{\partial p_i}{\partial \mu_i}\Big|_{\mu_i = 0} \leq 0 &amp; \text{ if } \mu_i = 0
\end{array}
\right.
</span> which in this case translates to the equations <span class="math display">
\left\{
\begin{array}{ll}
\displaystyle u_i'\left(\frac{\mu_i}{\sum_j \mu_j}\right)\left(1 - \frac{\mu_i}{\sum_j \mu_j}\right) = \sum_j \mu_j &amp; \text{ if } \mu_i &gt; 0 \\[3ex]
\displaystyle u_i'\left(0\right) \leq  \sum_j \mu_j &amp; \text{ if } \mu_i = 0
\end{array}
\right..
</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.14
</div>
</div>
<div class="callout-body-container callout-body">
<p>Verify the correctness of the first order conditions above.</p>
</div>
</div>
<p>We next write down the KKT conditions of the maximization problem above. The objective function is in fact concave, because the sum of concave functions is again a concave function. To see that <span class="math inline">\hat{u}_i</span> is concave for every <span class="math inline">i</span>, observe that <span class="math inline">\hat{u}_i' = (1-x_i)u_i'(x_i)</span>. This is the product of two decreasing functions (the latter function is decreasing because <span class="math inline">u_i</span> is concave), and, hence, also decreasing. Therefore, we may conclude that <span class="math inline">\hat{u}_i</span> is concave. Therefore, we are in fact dealing with a concave maximization problem subject to linear constraints for which the KKT conditions form a characterization of an optimal solution (see <a href="02-prelim.html#sec-prelim-concave-maximization" class="quarto-xref"><span>Section 2.4</span></a>).</p>
<p>Note that in what is to come, we switch between the hash rates <span class="math inline">\mu_i</span> and the market shares <span class="math inline">x_i</span> as variables. To align our setting with the description in <a href="02-prelim.html#sec-prelim-concave-maximization" class="quarto-xref"><span>Section 2.4</span></a>, we write the nonnegativity constraints as <span class="math inline">-x_i \leq 0</span> for <span class="math inline">i = 1,\dots,n</span>. Furthermore, we write the equality constraint as <span class="math inline">-(\sum_i x_i - 1) = 0</span> for notational convenience.</p>
<p>The Lagrangian of the maximization problem is then <span class="math display">
L(x,\lambda,\nu) = \sum_{i=1}^n \hat{u}_i(x_i) - \sum_{i=1}^n \lambda_i x_i - \nu \left(\sum_{i=1}^n x_i - 1\right),
</span> where <span class="math inline">\lambda = (\lambda_1,\dots,\lambda_n)</span>. Note that <span class="math inline">\nu</span> is a scalar and not a vector, because we only have one equality constraint. The KKT conditions reduce to the following:</p>
<ol type="1">
<li><strong>(Zero gradient).</strong> The partial derivatives of <span class="math inline">L</span> with respect to the <span class="math inline">x_i</span> are zero, i.e., <span class="math inline">\hat{u}_i'(x_i) - \lambda_i - \nu = 0 \text{ \ for \ } i = 1,\dots,n</span>. Note that <span class="math inline">u_i'(x_i) = -u_i(x_i) + (1-x_i)u_i'(x_i) + u_i(x_i) =  (1-x_i)u_i'(x_i)</span> so that the equations reduce to <span class="math display">
(1-x_i)u_i'(x_i) = \lambda_i + \nu  \text{ \ for \ } i = 1,\dots,n.
</span></li>
<li><strong>(Primal feasibility).</strong> <span class="math inline">x_i \geq 0</span> for <span class="math inline">i = 1,\dots,n</span> and <span class="math inline">\sum_i x_i = 1</span></li>
<li><strong>(Dual feasibility).</strong> <span class="math inline">\lambda_i \leq 0</span> for <span class="math inline">i = 1,\dots,n</span>.</li>
<li><strong>(Complementary slackness).</strong> <span class="math inline">\lambda_i x_i = 0</span> for <span class="math inline">i = 1,\dots,n</span>.</li>
</ol>
<p>A point <span class="math inline">x</span> solves the maximization problem if and only if there exists a point <span class="math inline">(x,\lambda,\nu)</span> satisfiying the KKT conditions. In the next exercise will wil show that in the latter case, <span class="math inline">x</span> equals the market shares of a pure Nash equilibrium</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.15
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that if a point <span class="math inline">(x,\lambda,\nu)</span> satisfies the KKT conditions, then <span class="math inline">x</span> corresponds to the market shares of the pure Nash equilibrium <span class="math inline">\mu = \nu\cdot x</span> where <span class="math inline">\nu = (1-x_i)u_i'(x_i)</span> for any choice of <span class="math inline">i</span> with <span class="math inline">x_i &gt; 0</span>.</p>
</div>
</div>
<p>This completes the proof of the theorem.</p>
<p>Recall from Exercise 8.11 that <span class="math inline">\hat{u}_i(x_i) = w_ix_i\left(1 - \frac{1}{2}x_i\right)</span> for <span class="math inline">u_i(z) = w_i z</span>. Below we solve the optimization problem for a Tullock contest with four miners with <span class="math inline">w_1 = 4, w_2 = 2, w_3 = 0.5, w_4 = 0.2</span> using <a href="https://docs.scipy.org/doc/scipy/tutorial/optimize.html">SciPy’s optimization package</a>.</p>
<style>
.cell-output-display {
  background-color: #ffffff;
}
</style>
<div id="2cec380f" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Show code for solving maximization problem</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> minimize</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Given data</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.array([<span class="dv">4</span>, <span class="dv">2</span>, <span class="fl">0.5</span>, <span class="fl">0.2</span>])  <span class="co"># Weights w_1, w_2, ..., w_n</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(w)  <span class="co"># Number of variables</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the utility function hat_u_i(x_i) for each i</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hat_u(x_i, w_i):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w_i <span class="op">*</span> x_i<span class="op">*</span>(<span class="dv">1</span> <span class="op">-</span>  x_i <span class="op">/</span> <span class="dv">2</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the total utility function to be maximized </span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># (negated for minimization)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> objective(x):</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>np.<span class="bu">sum</span>([hat_u(x[i], w[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)])</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the constraint: sum of x_i's must be 1</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constraint_sum(x):</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">sum</span>(x) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Bounds for each x_i (since x_i &gt;= 0)</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>bounds <span class="op">=</span> [(<span class="dv">0</span>, <span class="va">None</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial guess for the decision variables</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>x0 <span class="op">=</span> np.ones(n) <span class="op">/</span> n  <span class="co"># Initialize with equal distribution</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the constraint dictionary (sum of x_i's must be 1)</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> [{<span class="st">'type'</span>: <span class="st">'eq'</span>, <span class="st">'fun'</span>: constraint_sum}]</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve the optimization problem using the SLSQP method</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> minimize(objective, x0, method<span class="op">=</span><span class="st">'SLSQP'</span>, </span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>                    bounds<span class="op">=</span>bounds, constraints<span class="op">=</span>constraints)</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Output the results</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> result.success:</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Optimal decision variables (x_i):"</span>)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(np.<span class="bu">round</span>(result.x, <span class="dv">2</span>))  <span class="co"># Round to 2 decimal places</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Optimization failed:"</span>, result.message)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Optimal decision variables (x_i):
[0.67 0.33 0.   0.  ]</code></pre>
</div>
</div>
<p>In Exercise 8.4 we showed that the pure Nash equilibrium of this contest is given by <span class="math inline">\mu = (8/9,4/9,0,0)</span>, and so its market shares are <span class="math inline">x = (2/3,1/3,0,0)</span> using <span class="math inline">x_i = \mu_i/(\sum_j \mu_j)</span>. This indeed corresponds to the solution found by Python.</p>
<p>Can we also obtain the pure Nash equilibrium <span class="math inline">\mu</span> from the solution as opposed to only the market shares <span class="math inline">x</span>? Yes, by observing from the proof of <a href="#thm-pne-concave-utilities" class="quarto-xref">Theorem&nbsp;<span>8.4</span></a> that the normalizing constant is given by <span class="math inline">\nu = (1-x_i)u_i'(x_i)</span> for any <span class="math inline">i</span> with <span class="math inline">x_i &gt; 0</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> In our case we have <span class="math inline">u_i'(x_i) = w_i</span>. Taking <span class="math inline">i = 1</span>, we obtain <span class="math display">
\nu = (1-x_i)u_i'(x_i) = \left(1-\frac{2}{3}\right)u_1'\left(\frac{2}{3}\right) = \frac{1}{3}\cdot 4 = \frac{4}{3},
</span> so that <span class="math inline">\mu = \nu \cdot x = \frac{4}{3}\cdot (2/3,1/3,0,0) = (8/9,4/9,0,0).</span></p>
</section>
<section id="economies-of-scale" class="level3" data-number="8.4.2">
<h3 data-number="8.4.2" class="anchored" data-anchor-id="economies-of-scale"><span class="header-section-number">8.4.2</span> Economies of scale</h3>
<p>The second variation that we consider is when the payoff functions of the miners are, for <span class="math inline">\alpha &gt; 1</span>, given by <span class="math display">
p_i(\mu) = \frac{\mu_i^{\alpha}}{\sum_j \mu_j^{\alpha}} - a_i \mu_i.
</span> Recall that for <span class="math inline">\alpha = 1</span> this is the payoff form we started this chapter with (before doing the transformation <span class="math inline">w_i = 1/a_i)</span>.</p>
<p>The idea here is that the mining power grows quicker than the cost associated with mining. Mathematically speaking, if we invest <span class="math inline">a_i \mu_i</span> in mining power, then the hash rate becomes <span class="math inline">\mu_i^{\alpha}</span>, which grows (as a function of <span class="math inline">\mu_i</span>) at a faster rate than <span class="math inline">a_i\mu_i</span> because <span class="math inline">\alpha &gt; 1</span>. Such a setting, where mining power grows at a faster rate than investment costs, is called an <em>economy of scale</em> in the literature.</p>
<p>For sake of exposition we will assume that <span class="math inline">a_1 = \dots = a_n = 1</span>. Furthmore, also here we make the assumption that a best response against the all-zeros hash rate vector <span class="math inline">\mu_{-i} = (0,\dots,0)</span> is a sufficiently small number <span class="math inline">\delta &gt; 0</span>.</p>
<p>Computing a pure Nash equilibrium in closed form is not possible for this model. It is also not possible to phrase this problem as a concave maximization problem as we did in the previous section. Nevertheless, we can prove an interesting property of this model. If <span class="math inline">\mu</span> is a pure Nash equilibrium of this Tullock contest and miner <span class="math inline">i</span> has a strictly positive market share, i.e., <span class="math display">
x_i(\mu) = \frac{\mu_i^{\alpha}}{\sum_j \mu_j^{\alpha}} &gt; 0
</span> then it must be that <span class="math inline">x_i(\mu) = 1 - 1/\alpha</span>, i.e., miner <span class="math inline">i</span>’s market share can be bounded away from zero independent of the other hash rates.</p>
<p>This implies that there can be at most <span class="math inline">\alpha/(\alpha - 1)</span> miners active in the mining process in an equilibrium! For sake of illustration if <span class="math inline">\alpha = 1.1</span> then at most <span class="math inline">11</span> miners are active. This might explain, to some extent, why typically only a couple of “big players” are active in a mining markets (under the assumption of having an economy of scale).</p>
<p>We summarize the main result in the theorem below.</p>
<div id="thm-economies-of-scale" class="theorem">
<p><span class="theorem-title"><strong>Theorem 8.5 (Economies of scale)</strong></span> If the common payoff function of the Tullock contest, for <span class="math inline">\alpha &gt; 1</span>, is given by <span class="math display">
p_i(\mu) = \frac{\mu_i^{\alpha}}{\sum_j \mu_j^{\alpha}} - \mu_i = x_i(\mu) - \mu_i,
</span> then in a pure Nash equilibrium <span class="math inline">\mu</span>, for every <span class="math inline">i = 1,\dots,n</span> either <span class="math inline">x_i(\mu) = 0</span> or <span class="math inline">x_i(\mu) &gt; 1 - 1/\alpha</span>. This implies there can be at most <span class="math inline">\alpha/(\alpha - 1)</span> miners with strictly positive market share <span class="math inline">x_i(\mu)</span>.</p>
</div>
<p>We will prove this theorem in the following exercise.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.16
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let <span class="math inline">\mu</span> be a pure Nash equilibrium of the above Tullock contest.</p>
<ol type="1">
<li>Show that <span class="math inline">\mu_i = \alpha x_i(\mu)(1 - x_i(\mu))</span> for every <span class="math inline">i = 1,\dots,n</span> by optimizing the best response function <span class="math inline">g_i(z) = p_i(z,\mu_{-i})</span> over <span class="math inline">z \geq 0</span>.</li>
<li>Argue that, if <span class="math inline">x_i(\mu) &gt; 0</span>, then <span class="math inline">x_i(\mu) \geq 1 - 1/\alpha</span>. <em>Hint: Use that <span class="math inline">p_i(\mu) \geq 0</span> always holds and combine this with the equation from 1.</em></li>
</ol>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Exercise 8.17
</div>
</div>
<div class="callout-body-container callout-body">
<p>Show that if the common payoff function of the Tullock contest is given by <span class="math display">
p_i(\mu) = \frac{\mu_i^{\alpha}}{\sum_j \mu_j^{\alpha}} - \mu_i
</span> for <span class="math inline">\alpha &gt; 2</span> and <span class="math inline">i = 1,\dots,n</span> with <span class="math inline">n \geq 2</span>, then no pure Nash equilibrium exists in the game.</p>
</div>
</div>
</section>
</section>
<section id="acknowledgements" class="level2" data-number="8.5">
<h2 data-number="8.5" class="anchored" data-anchor-id="acknowledgements"><span class="header-section-number">8.5</span> Acknowledgements</h2>
<p>Section 8.1, 8.2 and 8.4.1 are loosely based on Chapter 4.4 of the book <a href="https://www.cambridge.org/core/books/contest-theory/D25DFD8F016963420A08A9526D7D2253">Contest Theory: Incentive Mechanisms and Ranking Methods</a> (2016) by Milan Vojnović. The Tullock contest has originally been defined by Tullock (1980).</p>
<p>Section 8.3 is based on the paper <a href="https://arxiv.org/pdf/2305.10881">Best-Response Dynamics in Lottery Contests</a> by Ghosh and Goldberg (2023). In particular, the example showing that best response dynamics might not converge is taken from this paper. The fact that the function <span class="math inline">P</span> in Section 2.3.1 is a best response potential function has been shown in the paper <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2913559">The Lottery Contest is a Best-Response Potential Game</a> by Ewerhart (2017).</p>
<p>Section 8.4.1 is based on the paper <a href="https://arxiv.org/pdf/1811.08572"> Bitcoin: A Natural Oligopoly</a> by Arnosti and Weinberg (2018).</p>


</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>There are many ways of doing this. You can use your own method as long as you add the proper argumentation for it.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The PNE is in fact unique, but we do not focus on this aspect here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>If you would use an optimization package like CVXPY in Python then there are more direct ways of obtaining the dual multipliers of the Lagrangian.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./07-proportional-rule.html" class="pagination-link" aria-label="Proportional rule">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Proportional rule</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>